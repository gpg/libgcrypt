# Configure.ac script for Libgcrypt
# Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2006,
#               2007, 2008, 2009, 2011 Free Software Foundation, Inc.
# Copyright (C) 2012-2024  g10 Code GmbH
#
# This file is part of Libgcrypt.
#
# Libgcrypt is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as
# published by the Free Software Foundation; either version 2.1 of
# the License, or (at your option) any later version.
#
# Libgcrypt is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, see <http://www.gnu.org/licenses/>.

# (Process this file with autoconf to produce a configure script.)
AC_REVISION($Revision$)
AC_PREREQ([2.69])
min_automake_version="1.14"

# To build a release you need to create a tag with the version number
# (git tag -s libgcrypt-n.m.k) and run "./autogen.sh --force".  Please
# bump the version number immediately after the release and do another
# commit and push so that the git magic is able to work.  See below
# for the LT versions.
m4_define([mym4_package],[libgcrypt])
m4_define([mym4_major], [1])
m4_define([mym4_minor], [11])
m4_define([mym4_micro], [2])

# Below is m4 magic to extract and compute the git revision number,
# the decimalized short revision number, a beta version string and a
# flag indicating a development version (mym4_isbeta).  Note that the
# m4 processing is done by autoconf and not during the configure run.
m4_define([mym4_verslist], m4_split(m4_esyscmd([./autogen.sh --find-version] \
                           mym4_package mym4_major mym4_minor mym4_micro),[:]))
m4_define([mym4_isbeta],       m4_argn(2, mym4_verslist))
m4_define([mym4_version],      m4_argn(4, mym4_verslist))
m4_define([mym4_revision],     m4_argn(7, mym4_verslist))
m4_define([mym4_revision_dec], m4_argn(8, mym4_verslist))
m4_esyscmd([echo ]mym4_version[>VERSION])
AC_INIT([mym4_package],[mym4_version],[https://bugs.gnupg.org])

# LT Version numbers, remember to change them just *before* a release.
#   (Code changed:			REVISION++)
#   (Interfaces added/removed/changed:	CURRENT++, REVISION=0)
#   (Interfaces added:			AGE++)
#   (Interfaces removed:		AGE=0)
#
#   (Interfaces removed:    CURRENT++, AGE=0, REVISION=0)
#   (Interfaces added:      CURRENT++, AGE++, REVISION=0)
#   (No interfaces changed:                   REVISION++)
# NOTE: Already upadated for 1.11.2 - remove this comment for release
LIBGCRYPT_LT_CURRENT=26
LIBGCRYPT_LT_AGE=6
LIBGCRYPT_LT_REVISION=0
################################################

AC_SUBST(LIBGCRYPT_LT_CURRENT)
AC_SUBST(LIBGCRYPT_LT_AGE)
AC_SUBST(LIBGCRYPT_LT_REVISION)

# If the API is changed in an incompatible way: increment the next counter.
#
# 1.6: ABI and API change but the change is to most users irrelevant
#      and thus the API version number has not been incremented.
LIBGCRYPT_CONFIG_API_VERSION=1

# If you change the required gpg-error version, please remove
# unnecessary error code defines in src/gcrypt-int.h.
NEED_GPG_ERROR_VERSION=1.49

AC_CONFIG_AUX_DIR([build-aux])
AC_CONFIG_SRCDIR([src/libgcrypt.vers])
AM_INIT_AUTOMAKE([serial-tests dist-bzip2])
AC_CONFIG_HEADERS([config.h])
AC_CONFIG_MACRO_DIR([m4])
AC_CONFIG_LIBOBJ_DIR([compat])
AC_CANONICAL_HOST
AM_MAINTAINER_MODE
AM_SILENT_RULES
AC_USE_SYSTEM_EXTENSIONS

AC_ARG_VAR(SYSROOT,[locate config scripts also below that directory])

AH_TOP([
#ifndef _GCRYPT_CONFIG_H_INCLUDED
#define _GCRYPT_CONFIG_H_INCLUDED
])

AH_BOTTOM([
#define _GCRYPT_IN_LIBGCRYPT 1

/* Add .note.gnu.property section for Intel CET in assembler sources
   when CET is enabled.  */
#if defined(__ASSEMBLER__) && defined(__CET__)
# include <cet.h>
#endif

/* If the configure check for endianness has been disabled, get it from
   OS macros.  This is intended for making fat binary builds on OS X.  */
#ifdef DISABLED_ENDIAN_CHECK
# if defined(__BIG_ENDIAN__)
#  define WORDS_BIGENDIAN 1
# elif defined(__LITTLE_ENDIAN__)
#  undef WORDS_BIGENDIAN
# else
#  error "No endianness found"
# endif
#endif /*DISABLED_ENDIAN_CHECK*/

/* We basically use the original Camellia source.  Make sure the symbols
   properly prefixed.  */
#define CAMELLIA_EXT_SYM_PREFIX _gcry_

#endif /*_GCRYPT_CONFIG_H_INCLUDED*/
])

AH_VERBATIM([_REENTRANT],
[/* To allow the use of Libgcrypt in multithreaded programs we have to use
    special features from the library. */
#ifndef _REENTRANT
# define _REENTRANT 1
#endif
])


######################
##  Basic checks.  ### (we need some results later on (e.g. $GCC)
######################

AC_PROG_MAKE_SET
missing_dir=`cd $ac_aux_dir && pwd`
AM_MISSING_PROG(ACLOCAL, aclocal, $missing_dir)
AM_MISSING_PROG(AUTOCONF, autoconf, $missing_dir)
AM_MISSING_PROG(AUTOMAKE, automake, $missing_dir)
AM_MISSING_PROG(AUTOHEADER, autoheader, $missing_dir)
# AM_MISSING_PROG(MAKEINFO, makeinfo, $missing_dir)
AC_PROG_CC
AC_PROG_CPP
AM_PROG_CC_C_O
AM_PROG_AS
AC_SEARCH_LIBS([strerror],[cposix])
AC_PROG_INSTALL
AC_PROG_AWK
AC_PROG_FGREP

# Taken from mpfr-4.0.1, then modified for LDADD_FOR_TESTS_KLUDGE
dnl Under Linux, make sure that the old dtags are used if LD_LIBRARY_PATH
dnl is defined. The issue is that with the new dtags, LD_LIBRARY_PATH has
dnl the precedence over the run path, so that if a compatible MPFR library
dnl is installed in some directory from $LD_LIBRARY_PATH, then the tested
dnl MPFR library will be this library instead of the MPFR library from the
dnl build tree. Other OS with the same issue might be added later.
dnl
dnl References:
dnl   https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=859732
dnl   http://lists.gnu.org/archive/html/libtool/2017-05/msg00000.html
dnl
dnl We need to check whether --disable-new-dtags is supported as alternate
dnl linkers may be used (e.g., with tcc: CC=tcc LD=tcc).
dnl
case $host in
  *-*-linux*)
    if test -n "$LD_LIBRARY_PATH"; then
      saved_LDFLAGS="$LDFLAGS"
      LDADD_FOR_TESTS_KLUDGE="-Wl,--disable-new-dtags"
      LDFLAGS="$LDFLAGS $LDADD_FOR_TESTS_KLUDGE"
      AC_MSG_CHECKING(whether --disable-new-dtags is supported by the linker)
      AC_LINK_IFELSE([AC_LANG_SOURCE([[
int main (void) { return 0; }
      ]])],
      [AC_MSG_RESULT(yes (use it since LD_LIBRARY_PATH is set))],
      [AC_MSG_RESULT(no)
       LDADD_FOR_TESTS_KLUDGE=""
      ])
      LDFLAGS="$saved_LDFLAGS"
    fi
    ;;
esac
AC_SUBST([LDADD_FOR_TESTS_KLUDGE])

VERSION_NUMBER=m4_esyscmd(printf "0x%02x%02x%02x" mym4_major \
                          mym4_minor mym4_micro)
AC_SUBST(VERSION_NUMBER)

# We need to compile and run a program on the build machine.
AX_CC_FOR_BUILD


LT_PREREQ([2.2.6])
LT_INIT([win32-dll disable-static])
LT_LANG([Windows Resource])


##########################
## General definitions. ##
##########################

# Used by libgcrypt-config
LIBGCRYPT_CONFIG_LIBS="-lgcrypt"
LIBGCRYPT_CONFIG_CFLAGS=""
LIBGCRYPT_CONFIG_HOST="$host"

# Definitions for symmetric ciphers.
available_ciphers="arcfour blowfish cast5 des aes twofish serpent rfc2268 seed"
available_ciphers="$available_ciphers camellia idea salsa20 gost28147 chacha20"
available_ciphers="$available_ciphers sm4 aria"
enabled_ciphers=""

# Definitions for public-key ciphers.
available_pubkey_ciphers="dsa elgamal rsa ecc kyber"
enabled_pubkey_ciphers=""

# Definitions for message digests.
available_digests="crc gostr3411-94 md2 md4 md5 rmd160 sha1 sha256 sha512"
available_digests="$available_digests sha3 tiger whirlpool stribog blake2"
available_digests="$available_digests sm3"
enabled_digests=""

# Definitions for kdfs (optional ones)
available_kdfs="s2k pkdf2 scrypt"
enabled_kdfs=""

# Definitions for random modules.
available_random_modules="getentropy linux egd unix"
auto_random_modules="$available_random_modules"

# Supported thread backends.
LIBGCRYPT_THREAD_MODULES=""

# Other definitions.
have_w32_system=no
have_pthread=no


# Setup some stuff depending on host.
case "${host}" in
    *-*-mingw32*)
      ac_cv_have_dev_random=no
      have_w32_system=yes
      available_random_modules="w32"
      AC_DEFINE(USE_ONLY_8DOT3,1,
                [set this to limit filenames to the 8.3 format])
      AC_DEFINE(HAVE_DRIVE_LETTERS,1,
                [defined if we must run on a stupid file system])
      AC_DEFINE(HAVE_DOSISH_SYSTEM,1,
                [defined if we run on some of the PCDOS like systems
                 (DOS, Windoze. OS/2) with special properties like
                  no file modes])
      ;;

    i?86-emx-os2 | i?86-*-os2*emx)
        # OS/2 with the EMX environment
        ac_cv_have_dev_random=no
        AC_DEFINE(HAVE_DRIVE_LETTERS)
        AC_DEFINE(HAVE_DOSISH_SYSTEM)
        ;;

    i?86-*-msdosdjgpp*)
        # DOS with the DJGPP environment
        ac_cv_have_dev_random=no
        AC_DEFINE(HAVE_DRIVE_LETTERS)
        AC_DEFINE(HAVE_DOSISH_SYSTEM)
        ;;

    *-*-hpux*)
        if test -z "$GCC" ; then
            CFLAGS="$CFLAGS -Ae -D_HPUX_SOURCE"
        fi
        ;;
    *-dec-osf4*)
        if test -z "$GCC" ; then
            # Suppress all warnings
            # to get rid of the unsigned/signed char mismatch warnings.
            CFLAGS="$CFLAGS -w"
        fi
        ;;
    m68k-atari-mint)
        ;;
    *-apple-darwin*)
        AC_DEFINE(_DARWIN_C_SOURCE, 1,
                  Expose all libc features (__DARWIN_C_FULL).)
        AC_DEFINE(USE_POSIX_SPAWN_FOR_TESTS, 1,
                  [defined if we use posix_spawn in test program])
        AC_CHECK_HEADERS(spawn.h)
        ;;
    *)
      ;;
esac

if test "$have_w32_system" = yes; then
   AC_DEFINE(HAVE_W32_SYSTEM,1, [Defined if we run on a W32 API based system])
fi
AM_CONDITIONAL(HAVE_W32_SYSTEM, test "$have_w32_system" = yes)


# A printable OS Name is sometimes useful.
case "${host}" in
    *-*-mingw32*)
        PRINTABLE_OS_NAME="W32"
        ;;

    i?86-emx-os2 | i?86-*-os2*emx )
        PRINTABLE_OS_NAME="OS/2"
        ;;

    i?86-*-msdosdjgpp*)
        PRINTABLE_OS_NAME="MSDOS/DJGPP"
        ;;

    *-linux*)
        PRINTABLE_OS_NAME="GNU/Linux"
        ;;

    *)
        PRINTABLE_OS_NAME=`uname -s || echo "Unknown"`
        ;;
esac

NAME_OF_DEV_RANDOM="/dev/random"
NAME_OF_DEV_URANDOM="/dev/urandom"

AC_ARG_ENABLE(endian-check,
              AS_HELP_STRING([--disable-endian-check],
              [disable the endian check and trust the OS provided macros]),
	      endiancheck=$enableval,endiancheck=yes)
if test x"$endiancheck" = xyes ; then
  AC_C_BIGENDIAN
else
  AC_DEFINE(DISABLED_ENDIAN_CHECK,1,[configure did not test for endianness])
fi

AC_CHECK_SIZEOF(unsigned short, 2)
AC_CHECK_SIZEOF(unsigned int, 4)
AC_CHECK_SIZEOF(unsigned long, 4)
AC_CHECK_SIZEOF(unsigned long long, 0)
AC_CHECK_SIZEOF(unsigned __int128, 0)
AC_CHECK_SIZEOF(void *, 0)

AC_TYPE_UINTPTR_T

if test "$ac_cv_sizeof_unsigned_short" = "0" \
   || test "$ac_cv_sizeof_unsigned_int" = "0" \
   || test "$ac_cv_sizeof_unsigned_long" = "0"; then
    AC_MSG_WARN([Hmmm, something is wrong with the sizes - using defaults]);
fi

# Ensure that we have UINT64_C before we bother to check for uint64_t
AC_CACHE_CHECK([for UINT64_C],[gnupg_cv_uint64_c_works],
   AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <inttypes.h>]],
       [[uint64_t foo=UINT64_C(42);]])],
     gnupg_cv_uint64_c_works=yes,gnupg_cv_uint64_c_works=no))
if test "$gnupg_cv_uint64_c_works" = "yes" ; then
   AC_CHECK_SIZEOF(uint64_t)
fi

# Do we have any 64-bit data types?
if test "$ac_cv_sizeof_unsigned_int" != "8" \
   && test "$ac_cv_sizeof_unsigned_long" != "8" \
   && test "$ac_cv_sizeof_unsigned_long_long" != "8" \
   && test "$ac_cv_sizeof_uint64_t" != "8"; then
    AC_MSG_ERROR([[
***
*** No 64-bit integer type available.
*** It is not possible to build Libgcrypt on this platform.
***]])
fi


# If not specified otherwise, all available algorithms will be
# included.
default_ciphers="$available_ciphers"
default_pubkey_ciphers="$available_pubkey_ciphers"
default_digests="$available_digests"
default_kdfs="$available_kdfs"
# Blacklist MD2 by default
default_digests=`echo $default_digests | sed -e 's/md2//g'`

# Substitutions to set generated files in a Emacs buffer to read-only.
AC_SUBST(emacs_local_vars_begin, ['Local Variables:'])
AC_SUBST(emacs_local_vars_read_only, ['buffer-read-only: t'])
AC_SUBST(emacs_local_vars_end, ['End:'])

############################
## Command line switches. ##
############################

# Implementation of the --enable-ciphers switch.
AC_ARG_ENABLE(ciphers,
	      AS_HELP_STRING([--enable-ciphers=ciphers],
                             [select the symmetric ciphers to include]),
	      [enabled_ciphers=`echo $enableval | tr ',:' '  ' | tr '[A-Z]' '[a-z]'`],
	      [enabled_ciphers=""])
if test "x$enabled_ciphers" = "x" \
   -o "$enabled_ciphers" = "yes"  \
   -o "$enabled_ciphers" = "no"; then
   enabled_ciphers=$default_ciphers
fi
AC_MSG_CHECKING([which symmetric ciphers to include])
for cipher in $enabled_ciphers; do
    LIST_MEMBER($cipher, $available_ciphers)
    if test "$found" = "0"; then
       AC_MSG_ERROR([unsupported cipher "$cipher" specified])
    fi
done
AC_MSG_RESULT([$enabled_ciphers])

# Implementation of the --enable-pubkey-ciphers switch.
AC_ARG_ENABLE(pubkey-ciphers,
	      AS_HELP_STRING([--enable-pubkey-ciphers=ciphers],
                             [select the public-key ciphers to include]),
	      [enabled_pubkey_ciphers=`echo $enableval | tr ',:' '  ' | tr '[A-Z]' '[a-z]'`],
	      [enabled_pubkey_ciphers=""])
if test "x$enabled_pubkey_ciphers" = "x" \
   -o "$enabled_pubkey_ciphers" = "yes"  \
   -o "$enabled_pubkey_ciphers" = "no"; then
   enabled_pubkey_ciphers=$default_pubkey_ciphers
fi
AC_MSG_CHECKING([which public-key ciphers to include])
for cipher in $enabled_pubkey_ciphers; do
    LIST_MEMBER($cipher, $available_pubkey_ciphers)
    if test "$found" = "0"; then
       AC_MSG_ERROR([unsupported public-key cipher specified])
    fi
done
AC_MSG_RESULT([$enabled_pubkey_ciphers])

# Implementation of the --enable-digests switch.
AC_ARG_ENABLE(digests,
	      AS_HELP_STRING([--enable-digests=digests],
                             [select the message digests to include]),
	      [enabled_digests=`echo $enableval | tr ',:' '  ' | tr '[A-Z]' '[a-z]'`],
	      [enabled_digests=""])
if test "x$enabled_digests" = "x" \
   -o "$enabled_digests" = "yes"  \
   -o "$enabled_digests" = "no"; then
   enabled_digests=$default_digests
fi
AC_MSG_CHECKING([which message digests to include])
for digest in $enabled_digests; do
    LIST_MEMBER($digest, $available_digests)
    if test "$found" = "0"; then
       AC_MSG_ERROR([unsupported message digest specified])
    fi
done
AC_MSG_RESULT([$enabled_digests])

# Implementation of the --enable-kdfs switch.
AC_ARG_ENABLE(kdfs,
      AS_HELP_STRING([--enable-kfds=kdfs],
                     [select the KDFs to include]),
      [enabled_kdfs=`echo $enableval | tr ',:' '  ' | tr '[A-Z]' '[a-z]'`],
      [enabled_kdfs=""])
if test "x$enabled_kdfs" = "x" \
   -o "$enabled_kdfs" = "yes"  \
   -o "$enabled_kdfs" = "no"; then
   enabled_kdfs=$default_kdfs
fi
AC_MSG_CHECKING([which key derivation functions to include])
for kdf in $enabled_kdfs; do
    LIST_MEMBER($kdf, $available_kdfs)
    if test "$found" = "0"; then
       AC_MSG_ERROR([unsupported key derivation function specified])
    fi
done
AC_MSG_RESULT([$enabled_kdfs])

# Implementation of the --enable-random switch.
AC_ARG_ENABLE(random,
	      AS_HELP_STRING([--enable-random=name],
                             [select which random number generator to use]),
	      [random=`echo $enableval | tr '[A-Z]' '[a-z]'`],
	      [])
if test "x$random" = "x" -o "$random" = "yes" -o "$random" = "no"; then
    random=default
fi
AC_MSG_CHECKING([which random module to use])
if test "$random" != "default" -a "$random" != "auto"; then
    LIST_MEMBER($random, $available_random_modules)
    if test "$found" = "0"; then
       AC_MSG_ERROR([unsupported random module specified])
    fi
fi
AC_MSG_RESULT($random)

# Implementation of the --disable-dev-random switch.
AC_MSG_CHECKING([whether use of /dev/random is requested])
AC_ARG_ENABLE(dev-random,
[  --disable-dev-random    disable the use of dev random],
    try_dev_random=$enableval, try_dev_random=yes)
AC_MSG_RESULT($try_dev_random)

# Implementation of the --with-egd-socket switch.
AC_ARG_WITH(egd-socket,
    [  --with-egd-socket=NAME  Use NAME for the EGD socket)],
            egd_socket_name="$withval", egd_socket_name="" )
AC_DEFINE_UNQUOTED(EGD_SOCKET_NAME, "$egd_socket_name",
                   [Define if you don't want the default EGD socket name.
                    For details see cipher/rndegd.c])


# Implementation of --disable-asm.
AC_MSG_CHECKING([whether MPI and cipher assembler modules are requested])
AC_ARG_ENABLE([asm],
              AS_HELP_STRING([--disable-asm],
                             [Disable MPI and cipher assembler modules]),
              [try_asm_modules=$enableval],
              [try_asm_modules=yes])
AC_MSG_RESULT($try_asm_modules)
if test "$try_asm_modules" != yes ; then
    AC_DEFINE(ASM_DISABLED,1,[Defined if --disable-asm was used to configure])
fi

# Implementation of the --enable-large-data-tests switch.
AC_MSG_CHECKING([whether to run large data tests])
AC_ARG_ENABLE(large-data-tests,
              AS_HELP_STRING([--enable-large-data-tests],
                 [Enable the real long ruinning large data tests]),
	      large_data_tests=$enableval,large_data_tests=no)
AC_MSG_RESULT($large_data_tests)
AC_SUBST(RUN_LARGE_DATA_TESTS, $large_data_tests)

# Implementation of --enable-force-soft-hwfeatures
AC_MSG_CHECKING([whether 'soft' HW feature bits are forced on])
AC_ARG_ENABLE([force-soft-hwfeatures],
              AS_HELP_STRING([--enable-force-soft-hwfeatures],
                             [Enable forcing 'soft' HW feature bits on]),
              [force_soft_hwfeatures=$enableval],
              [force_soft_hwfeatures=no])
AC_MSG_RESULT($force_soft_hwfeatures)


# Implementation of the --with-capabilities switch.
# Check whether we want to use Linux capabilities
AC_MSG_CHECKING([whether use of capabilities is requested])
AC_ARG_WITH(capabilities,
            AS_HELP_STRING([--with-capabilities],
                           [Use linux capabilities [default=no]]),
            [use_capabilities="$withval"],[use_capabilities=no])
AC_MSG_RESULT($use_capabilities)

# Implementation of the --enable-hmac-binary-check.
AC_MSG_CHECKING([whether a HMAC binary check is requested])
AC_ARG_ENABLE(hmac-binary-check,
              AS_HELP_STRING([--enable-hmac-binary-check],
                             [Enable library integrity check]),
              [use_hmac_binary_check="$enableval"],
              [use_hmac_binary_check=no])
AC_MSG_RESULT($use_hmac_binary_check)
if test "$use_hmac_binary_check" = no ; then
    DEF_HMAC_BINARY_CHECK=''
else
    AC_DEFINE(ENABLE_HMAC_BINARY_CHECK,1,
              [Define to support an HMAC based integrity check])
    AC_CHECK_TOOL(OBJCOPY, [objcopy])
    AC_CHECK_TOOL(READELF, [readelf])
    if test "$use_hmac_binary_check" != yes ; then
        DEF_HMAC_BINARY_CHECK=-DKEY_FOR_BINARY_CHECK="'\"$use_hmac_binary_check\"'"
    fi
fi
AM_CONDITIONAL(USE_HMAC_BINARY_CHECK, test "x$use_hmac_binary_check" != xno)
AC_SUBST(DEF_HMAC_BINARY_CHECK)

# Implementation of the --with-fips-module-version.
AC_ARG_WITH(fips-module-version,
            AS_HELP_STRING([--with-fips-module-version=VERSION],
                           [Specify the FIPS module version for the build]),
            fips_module_version="$withval", fips_module_version="" )
AC_DEFINE_UNQUOTED(FIPS_MODULE_VERSION, "$fips_module_version",
                   [Define FIPS module version for certification])

# Implementation of the --disable-jent-support switch.
AC_MSG_CHECKING([whether jitter entropy support is requested])
AC_ARG_ENABLE(jent-support,
              AS_HELP_STRING([--disable-jent-support],
                        [Disable support for the Jitter entropy collector]),
	      jentsupport=$enableval,jentsupport=yes)
AC_MSG_RESULT($jentsupport)

# Implementation of the --disable-padlock-support switch.
AC_MSG_CHECKING([whether padlock support is requested])
AC_ARG_ENABLE(padlock-support,
              AS_HELP_STRING([--disable-padlock-support],
                        [Disable support for the PadLock Engine of VIA processors]),
	      padlocksupport=$enableval,padlocksupport=yes)
AC_MSG_RESULT($padlocksupport)

# Implementation of the --disable-aesni-support switch.
AC_MSG_CHECKING([whether AESNI support is requested])
AC_ARG_ENABLE(aesni-support,
              AS_HELP_STRING([--disable-aesni-support],
                 [Disable support for the Intel AES-NI instructions]),
	      aesnisupport=$enableval,aesnisupport=yes)
AC_MSG_RESULT($aesnisupport)

# Implementation of the --disable-shaext-support switch.
AC_MSG_CHECKING([whether SHAEXT support is requested])
AC_ARG_ENABLE(shaext-support,
              AS_HELP_STRING([--disable-shaext-support],
                 [Disable support for the Intel SHAEXT instructions]),
              shaextsupport=$enableval,shaextsupport=yes)
AC_MSG_RESULT($shaextsupport)

# Implementation of the --disable-pclmul-support switch.
AC_MSG_CHECKING([whether PCLMUL support is requested])
AC_ARG_ENABLE(pclmul-support,
              AS_HELP_STRING([--disable-pclmul-support],
                 [Disable support for the Intel PCLMUL instructions]),
	      pclmulsupport=$enableval,pclmulsupport=yes)
AC_MSG_RESULT($pclmulsupport)

# Implementation of the --disable-sse41-support switch.
AC_MSG_CHECKING([whether SSE4.1 support is requested])
AC_ARG_ENABLE(sse41-support,
              AS_HELP_STRING([--disable-sse41-support],
                 [Disable support for the Intel SSE4.1 instructions]),
	      sse41support=$enableval,sse41support=yes)
AC_MSG_RESULT($sse41support)

# Implementation of the --disable-drng-support switch.
AC_MSG_CHECKING([whether DRNG support is requested])
AC_ARG_ENABLE(drng-support,
              AS_HELP_STRING([--disable-drng-support],
                 [Disable support for the Intel DRNG (RDRAND instruction)]),
	      drngsupport=$enableval,drngsupport=yes)
AC_MSG_RESULT($drngsupport)

# Implementation of the --disable-avx-support switch.
AC_MSG_CHECKING([whether AVX support is requested])
AC_ARG_ENABLE(avx-support,
              AS_HELP_STRING([--disable-avx-support],
                 [Disable support for the Intel AVX instructions]),
	      avxsupport=$enableval,avxsupport=yes)
AC_MSG_RESULT($avxsupport)

# Implementation of the --disable-avx2-support switch.
AC_MSG_CHECKING([whether AVX2 support is requested])
AC_ARG_ENABLE(avx2-support,
              AS_HELP_STRING([--disable-avx2-support],
                 [Disable support for the Intel AVX2 instructions]),
	      avx2support=$enableval,avx2support=yes)
AC_MSG_RESULT($avx2support)

# Implementation of the --disable-avx512-support switch.
AC_MSG_CHECKING([whether AVX512 support is requested])
AC_ARG_ENABLE(avx512-support,
              AS_HELP_STRING([--disable-avx512-support],
                 [Disable support for the Intel AVX512 instructions]),
	      avx512support=$enableval,avx512support=yes)
AC_MSG_RESULT($avx512support)

# Implementation of the --disable-gfni-support switch.
AC_MSG_CHECKING([whether GFNI support is requested])
AC_ARG_ENABLE(gfni-support,
              AS_HELP_STRING([--disable-gfni-support],
                 [Disable support for the Intel GFNI instructions]),
	      gfnisupport=$enableval,gfnisupport=yes)
AC_MSG_RESULT($gfnisupport)

# Implementation of the --disable-neon-support switch.
AC_MSG_CHECKING([whether NEON support is requested])
AC_ARG_ENABLE(neon-support,
              AS_HELP_STRING([--disable-neon-support],
                 [Disable support for the ARM NEON instructions]),
	      neonsupport=$enableval,neonsupport=yes)
AC_MSG_RESULT($neonsupport)

# Implementation of the --disable-arm-crypto-support switch.
AC_MSG_CHECKING([whether ARMv8 Crypto Extension support is requested])
AC_ARG_ENABLE(arm-crypto-support,
              AS_HELP_STRING([--disable-arm-crypto-support],
                 [Disable support for the ARMv8 Crypto Extension instructions]),
	      armcryptosupport=$enableval,armcryptosupport=yes)
AC_MSG_RESULT($armcryptosupport)

# Implementation of the --disable-sve-support switch.
AC_MSG_CHECKING([whether SVE support is requested])
AC_ARG_ENABLE(sve-support,
              AS_HELP_STRING([--disable-sve-support],
                 [Disable support for the ARMv8 SVE instructions]),
	      svesupport=$enableval,svesupport=yes)
AC_MSG_RESULT($svesupport)

# Implementation of the --disable-sve2-support switch.
AC_MSG_CHECKING([whether SVE2 support is requested])
AC_ARG_ENABLE(sve2-support,
              AS_HELP_STRING([--disable-sve2-support],
                 [Disable support for the ARMv9 SVE2 instructions]),
	      sve2support=$enableval,sve2support=yes)
AC_MSG_RESULT($sve2support)

# Implementation of the --disable-ppc-crypto-support switch.
AC_MSG_CHECKING([whether PPC crypto support is requested])
AC_ARG_ENABLE(ppc-crypto-support,
              AS_HELP_STRING([--disable-ppc-crypto-support],
                 [Disable support for the PPC crypto instructions introduced in POWER 8 (PowerISA 2.07)]),
              ppccryptosupport=$enableval,ppccryptosupport=yes)
AC_MSG_RESULT($ppccryptosupport)

# Implementation of the --disable-O-flag-munging switch.
AC_MSG_CHECKING([whether a -O flag munging is requested])
AC_ARG_ENABLE([O-flag-munging],
              AS_HELP_STRING([--disable-O-flag-munging],
                 [Disable modification of the cc -O flag]),
              [enable_o_flag_munging=$enableval],
              [enable_o_flag_munging=yes])
AC_MSG_RESULT($enable_o_flag_munging)
AM_CONDITIONAL(ENABLE_O_FLAG_MUNGING, test "$enable_o_flag_munging" = "yes")

# Implementation of the --disable-instrumentation-munging switch.
AC_MSG_CHECKING([whether a instrumentation (-fprofile, -fsanitize) munging is requested])
AC_ARG_ENABLE([instrumentation-munging],
              AS_HELP_STRING([--disable-instrumentation-munging],
                 [Disable modification of the cc instrumentation options]),
              [enable_instrumentation_munging=$enableval],
              [enable_instrumentation_munging=yes])
AC_MSG_RESULT($enable_instrumentation_munging)
AM_CONDITIONAL(ENABLE_INSTRUMENTATION_MUNGING,
	       test "$enable_instrumentation_munging" = "yes")

# Implementation of the --disable-amd64-as-feature-detection switch.
AC_MSG_CHECKING([whether to enable AMD64 as(1) feature detection])
AC_ARG_ENABLE(amd64-as-feature-detection,
              AS_HELP_STRING([--disable-amd64-as-feature-detection],
                 [Disable the auto-detection of AMD64 as(1) features]),
	      amd64_as_feature_detection=$enableval,
              amd64_as_feature_detection=yes)
AC_MSG_RESULT($amd64_as_feature_detection)


AC_DEFINE_UNQUOTED(PRINTABLE_OS_NAME, "$PRINTABLE_OS_NAME",
                   [A human readable text with the name of the OS])

# For some systems we know that we have ld_version scripts.
# Use it then as default.
have_ld_version_script=no
case "${host}" in
    *-*-linux*)
	have_ld_version_script=yes
        ;;
    *-*-gnu*)
	have_ld_version_script=yes
        ;;
esac
AC_ARG_ENABLE([ld-version-script],
              AS_HELP_STRING([--enable-ld-version-script],
                             [enable/disable use of linker version script.
                              (default is system dependent)]),
              [have_ld_version_script=$enableval],
              [ : ] )
AM_CONDITIONAL(HAVE_LD_VERSION_SCRIPT, test "$have_ld_version_script" = "yes")

AC_DEFINE_UNQUOTED(NAME_OF_DEV_RANDOM, "$NAME_OF_DEV_RANDOM",
                   [defined to the name of the strong random device])
AC_DEFINE_UNQUOTED(NAME_OF_DEV_URANDOM, "$NAME_OF_DEV_URANDOM",
                   [defined to the name of the weaker random device])

#
# Specify how we support our local modification of libtool for Windows
# 64-bit.  Options are:
#
# (1) apply: when appying patch fails, it results failure of entire build
# (2) never: never apply the patch (no try)
# (3) try: use patched if it goes well, use original if fails
#
AC_ARG_WITH([libtool-modification],
  AS_HELP_STRING([--with-libtool-modification=apply|never|try],
                 [how to handle libtool modification (default=never)]),
                 build_libtool_modification=$withval,
                 build_libtool_modification=never)

#
# Apply a patch (locally maintained one of ours) to libtool
#
case $host in
  x86_64-*mingw32*)
AC_CONFIG_COMMANDS([libtool-patch],[[
  if test "$build_selection" = never; then
    echo "patch not applied"
  elif (mv -f libtool libtool.orig; \
        sed -f $srcdir/build-aux/libtool-patch.sed libtool.orig >libtool); then
    echo "applied successfully"
  elif test "$build_selection" = try; then
    mv -f libtool.orig libtool
    echo "patch failed, thus, using original"
  else
    echo "patch failed"
    as_fn_exit 1
  fi
]],[build_selection=$build_libtool_modification])
  ;;
  *)
  ;;
esac

###############################
#### Checks for libraries. ####
###############################

#
# gpg-error is required.
#
AM_PATH_GPG_ERROR("$NEED_GPG_ERROR_VERSION")
if test "x$GPG_ERROR_LIBS" = "x"; then
  AC_MSG_ERROR([libgpg-error is needed.
                See https://gnupg.org/ftp/gcrypt/gpgrt/ .])
fi

AC_DEFINE(GPG_ERR_SOURCE_DEFAULT, GPG_ERR_SOURCE_GCRYPT,
          [The default error source for libgcrypt.])

AM_CONDITIONAL(USE_GPGRT_CONFIG, [test -n "$GPGRT_CONFIG" \
                                  -a "$ac_cv_path_GPG_ERROR_CONFIG" = no])

#
# Check whether pthreads is available
#
if test "$have_w32_system" != yes; then
  AC_CHECK_LIB(pthread,pthread_create,have_pthread=yes)
  if test "$have_pthread" = yes; then
    AC_DEFINE(HAVE_PTHREAD, 1 ,[Define if we have pthread.])
  fi
fi


# Solaris needs -lsocket and -lnsl. Unisys system includes
# gethostbyname in libsocket but needs libnsl for socket.
AC_SEARCH_LIBS(setsockopt, [socket], ,
	[AC_SEARCH_LIBS(setsockopt, [socket], , , [-lnsl])])
AC_SEARCH_LIBS(setsockopt, [nsl])

##################################
#### Checks for header files. ####
##################################

AC_CHECK_HEADERS(unistd.h sys/auxv.h sys/random.h sys/sysctl.h)


##########################################
#### Checks for typedefs, structures, ####
####  and compiler characteristics.   ####
##########################################

AC_C_CONST
AC_C_INLINE
AC_TYPE_SIZE_T
AC_TYPE_PID_T

AC_CHECK_TYPES([byte, ushort, u16, u32, u64])

#
# Check for __builtin_bswap32 intrinsic.
#
AC_CACHE_CHECK(for __builtin_bswap32,
       [gcry_cv_have_builtin_bswap32],
       [gcry_cv_have_builtin_bswap32=no
        AC_LINK_IFELSE([AC_LANG_PROGRAM([],
          [int x = 0; int y = __builtin_bswap32(x); return y;])],
          [gcry_cv_have_builtin_bswap32=yes])])
if test "$gcry_cv_have_builtin_bswap32" = "yes" ; then
   AC_DEFINE(HAVE_BUILTIN_BSWAP32,1,
             [Defined if compiler has '__builtin_bswap32' intrinsic])
fi


#
# Check for __builtin_bswap64 intrinsic.
#
AC_CACHE_CHECK(for __builtin_bswap64,
       [gcry_cv_have_builtin_bswap64],
       [gcry_cv_have_builtin_bswap64=no
        AC_LINK_IFELSE([AC_LANG_PROGRAM([],
          [long long x = 0; long long y = __builtin_bswap64(x); return y;])],
          [gcry_cv_have_builtin_bswap64=yes])])
if test "$gcry_cv_have_builtin_bswap64" = "yes" ; then
   AC_DEFINE(HAVE_BUILTIN_BSWAP64,1,
             [Defined if compiler has '__builtin_bswap64' intrinsic])
fi


#
# Check for __builtin_ctz intrinsic.
#
AC_CACHE_CHECK(for __builtin_ctz,
       [gcry_cv_have_builtin_ctz],
       [gcry_cv_have_builtin_ctz=no
        AC_LINK_IFELSE([AC_LANG_PROGRAM([],
          [unsigned int x = 0; int y = __builtin_ctz(x); return y;])],
          [gcry_cv_have_builtin_ctz=yes])])
if test "$gcry_cv_have_builtin_ctz" = "yes" ; then
   AC_DEFINE(HAVE_BUILTIN_CTZ, 1,
             [Defined if compiler has '__builtin_ctz' intrinsic])
fi


#
# Check for __builtin_ctzl intrinsic.
#
AC_CACHE_CHECK(for __builtin_ctzl,
       [gcry_cv_have_builtin_ctzl],
       [gcry_cv_have_builtin_ctzl=no
        AC_LINK_IFELSE([AC_LANG_PROGRAM([],
          [unsigned long x = 0; long y = __builtin_ctzl(x); return y;])],
          [gcry_cv_have_builtin_ctzl=yes])])
if test "$gcry_cv_have_builtin_ctzl" = "yes" ; then
   AC_DEFINE(HAVE_BUILTIN_CTZL, 1,
             [Defined if compiler has '__builtin_ctzl' intrinsic])
fi


#
# Check for __builtin_clz intrinsic.
#
AC_CACHE_CHECK(for __builtin_clz,
       [gcry_cv_have_builtin_clz],
       [gcry_cv_have_builtin_clz=no
        AC_LINK_IFELSE([AC_LANG_PROGRAM([],
          [unsigned int x = 0; int y = __builtin_clz(x); return y;])],
          [gcry_cv_have_builtin_clz=yes])])
if test "$gcry_cv_have_builtin_clz" = "yes" ; then
   AC_DEFINE(HAVE_BUILTIN_CLZ, 1,
             [Defined if compiler has '__builtin_clz' intrinsic])
fi


#
# Check for __builtin_clzl intrinsic.
#
AC_CACHE_CHECK(for __builtin_clzl,
       [gcry_cv_have_builtin_clzl],
       [gcry_cv_have_builtin_clzl=no
        AC_LINK_IFELSE([AC_LANG_PROGRAM([],
          [unsigned long x = 0; long y = __builtin_clzl(x); return y;])],
          [gcry_cv_have_builtin_clzl=yes])])
if test "$gcry_cv_have_builtin_clzl" = "yes" ; then
   AC_DEFINE(HAVE_BUILTIN_CLZL, 1,
             [Defined if compiler has '__builtin_clzl' intrinsic])
fi


#
# Check for __sync_synchronize intrinsic.
#
AC_CACHE_CHECK(for __sync_synchronize,
       [gcry_cv_have_sync_synchronize],
       [gcry_cv_have_sync_synchronize=no
        AC_LINK_IFELSE([AC_LANG_PROGRAM([],
          [__sync_synchronize(); return 0;])],
          [gcry_cv_have_sync_synchronize=yes])])
if test "$gcry_cv_have_sync_synchronize" = "yes" ; then
   AC_DEFINE(HAVE_SYNC_SYNCHRONIZE, 1,
             [Defined if compiler has '__sync_synchronize' intrinsic])
fi


#
# Check for VLA support (variable length arrays).
#
AC_CACHE_CHECK(whether the variable length arrays are supported,
       [gcry_cv_have_vla],
       [gcry_cv_have_vla=no
        AC_COMPILE_IFELSE([AC_LANG_SOURCE(
          [[void f1(char *, int);
            char foo(int i) {
              char b[(i < 0 ? 0 : i) + 1];
              f1(b, sizeof b); return b[0];}]])],
          [gcry_cv_have_vla=yes])])
if test "$gcry_cv_have_vla" = "yes" ; then
   AC_DEFINE(HAVE_VLA,1, [Defined if variable length arrays are supported])
fi


#
# Check for ELF visibility support.
#
AC_CACHE_CHECK(whether the visibility attribute is supported,
       gcry_cv_visibility_attribute,
       [gcry_cv_visibility_attribute=no
        AC_LANG_CONFTEST([AC_LANG_SOURCE(
          [[int foo __attribute__ ((visibility ("hidden"))) = 1;
            int bar __attribute__ ((visibility ("protected"))) = 1;
          ]])])

        if ${CC-cc} -Werror -S conftest.c -o conftest.s \
                  1>&AS_MESSAGE_LOG_FD 2>&AS_MESSAGE_LOG_FD ; then
            if grep '\.hidden.*foo' conftest.s >/dev/null 2>&1 ; then
                if grep '\.protected.*bar' conftest.s >/dev/null 2>&1; then
                    gcry_cv_visibility_attribute=yes
                fi
            fi
        fi
       ])
if test "$gcry_cv_visibility_attribute" = "yes"; then
    AC_CACHE_CHECK(for broken visibility attribute,
       gcry_cv_broken_visibility_attribute,
       [gcry_cv_broken_visibility_attribute=yes
        AC_LANG_CONFTEST([AC_LANG_SOURCE(
          [[int foo (int x);
            int bar (int x) __asm__ ("foo")
                            __attribute__ ((visibility ("hidden")));
            int bar (int x) { return x; }
          ]])])

        if ${CC-cc} -Werror -S conftest.c -o conftest.s \
                  1>&AS_MESSAGE_LOG_FD 2>&AS_MESSAGE_LOG_FD ; then
           if grep '\.hidden@<:@ 	_@:>@foo' conftest.s >/dev/null 2>&1;
            then
               gcry_cv_broken_visibility_attribute=no
           fi
        fi
       ])
fi
if test "$gcry_cv_visibility_attribute" = "yes"; then
    AC_CACHE_CHECK(for broken alias attribute,
       gcry_cv_broken_alias_attribute,
       [gcry_cv_broken_alias_attribute=yes
        AC_LANG_CONFTEST([AC_LANG_SOURCE(
          [[extern int foo (int x) __asm ("xyzzy");
            int bar (int x) { return x; }
            extern __typeof (bar) foo __attribute ((weak, alias ("bar")));
            extern int dfoo;
            extern __typeof (dfoo) dfoo __asm ("abccb");
            int dfoo = 1;
          ]])])

        if ${CC-cc} -Werror -S conftest.c -o conftest.s \
                  1>&AS_MESSAGE_LOG_FD 2>&AS_MESSAGE_LOG_FD ; then
           if grep 'xyzzy' conftest.s >/dev/null 2>&1 && \
              grep 'abccb' conftest.s >/dev/null 2>&1; then
              gcry_cv_broken_alias_attribute=no
           fi
        fi
        ])
fi
if test "$gcry_cv_visibility_attribute" = "yes"; then
    AC_CACHE_CHECK(if gcc supports -fvisibility=hidden,
       gcry_cv_gcc_has_f_visibility,
       [gcry_cv_gcc_has_f_visibility=no
        _gcc_cflags_save=$CFLAGS
        CFLAGS="-fvisibility=hidden"
        AC_COMPILE_IFELSE([AC_LANG_PROGRAM([],[])],
                          gcry_cv_gcc_has_f_visibility=yes)
        CFLAGS=$_gcc_cflags_save;
       ])
fi
if test "$gcry_cv_visibility_attribute" = "yes" \
   && test "$gcry_cv_broken_visibility_attribute" != "yes" \
   && test "$gcry_cv_broken_alias_attribute" != "yes" \
   && test "$gcry_cv_gcc_has_f_visibility" = "yes"
 then
   AC_DEFINE(GCRY_USE_VISIBILITY, 1,
               [Define to use the GNU C visibility attribute.])
   CFLAGS="$CFLAGS -fvisibility=hidden"
fi


# Following attribute tests depend on warnings to cause compile to fail,
# so set -Werror temporarily.
_gcc_cflags_save=$CFLAGS
CFLAGS="$CFLAGS -Werror"


#
# Check whether the compiler supports the GCC style aligned attribute
#
AC_CACHE_CHECK([whether the GCC style aligned attribute is supported],
       [gcry_cv_gcc_attribute_aligned],
       [gcry_cv_gcc_attribute_aligned=no
        AC_COMPILE_IFELSE([AC_LANG_SOURCE(
          [[struct { int a; } foo __attribute__ ((aligned (16)));]])],
          [gcry_cv_gcc_attribute_aligned=yes])])
if test "$gcry_cv_gcc_attribute_aligned" = "yes" ; then
   AC_DEFINE(HAVE_GCC_ATTRIBUTE_ALIGNED,1,
     [Defined if a GCC style "__attribute__ ((aligned (n))" is supported])
fi


#
# Check whether the compiler supports the GCC style packed attribute
#
AC_CACHE_CHECK([whether the GCC style packed attribute is supported],
       [gcry_cv_gcc_attribute_packed],
       [gcry_cv_gcc_attribute_packed=no
        AC_COMPILE_IFELSE([AC_LANG_SOURCE(
          [[struct foolong_s { long b; } __attribute__ ((packed));
            struct foo_s { char a; struct foolong_s b; }
              __attribute__ ((packed));
            enum bar {
              FOO = 1 / (sizeof(struct foo_s) == (sizeof(char) + sizeof(long))),
            };]])],
          [gcry_cv_gcc_attribute_packed=yes])])
if test "$gcry_cv_gcc_attribute_packed" = "yes" ; then
   AC_DEFINE(HAVE_GCC_ATTRIBUTE_PACKED,1,
     [Defined if a GCC style "__attribute__ ((packed))" is supported])
fi


#
# Check whether the compiler supports the GCC style may_alias attribute
#
AC_CACHE_CHECK([whether the GCC style may_alias attribute is supported],
       [gcry_cv_gcc_attribute_may_alias],
       [gcry_cv_gcc_attribute_may_alias=no
        AC_COMPILE_IFELSE([AC_LANG_SOURCE(
          [[typedef struct foo_s { int a; }
            __attribute__ ((may_alias)) foo_t;]])],
          [gcry_cv_gcc_attribute_may_alias=yes])])
if test "$gcry_cv_gcc_attribute_may_alias" = "yes" ; then
   AC_DEFINE(HAVE_GCC_ATTRIBUTE_MAY_ALIAS,1,
     [Defined if a GCC style "__attribute__ ((may_alias))" is supported])
fi


# Restore flags.
CFLAGS=$_gcc_cflags_save;


#
# Check whether the compiler supports 'asm' or '__asm__' keyword for
# assembler blocks.
#
AC_CACHE_CHECK([whether 'asm' assembler keyword is supported],
       [gcry_cv_have_asm],
       [gcry_cv_have_asm=no
        AC_COMPILE_IFELSE([AC_LANG_SOURCE(
          [[void a(void) { asm("":::"memory"); }]])],
          [gcry_cv_have_asm=yes])])
AC_CACHE_CHECK([whether '__asm__' assembler keyword is supported],
       [gcry_cv_have___asm__],
       [gcry_cv_have___asm__=no
        AC_COMPILE_IFELSE([AC_LANG_SOURCE(
          [[void a(void) { __asm__("":::"memory"); }]])],
          [gcry_cv_have___asm__=yes])])
if test "$gcry_cv_have_asm" = "no" ; then
   if test "$gcry_cv_have___asm__" = "yes" ; then
      AC_DEFINE(asm,__asm__,
        [Define to supported assembler block keyword, if plain 'asm' was not
         supported])
   fi
fi


#
# Check whether the compiler supports inline assembly memory barrier.
#
if test "$gcry_cv_have_asm" = "no" ; then
   if test "$gcry_cv_have___asm__" = "yes" ; then
      AC_CACHE_CHECK([whether inline assembly memory barrier is supported],
          [gcry_cv_have_asm_volatile_memory],
          [gcry_cv_have_asm_volatile_memory=no
           AC_COMPILE_IFELSE([AC_LANG_SOURCE(
             [[void a(int x)
               {
                 __asm__ volatile("":::"memory");
                 __asm__ volatile("":"+r"(x)::"memory");
               }]])],
             [gcry_cv_have_asm_volatile_memory=yes])])
   fi
else
   AC_CACHE_CHECK([whether inline assembly memory barrier is supported],
       [gcry_cv_have_asm_volatile_memory],
       [gcry_cv_have_asm_volatile_memory=no
        AC_COMPILE_IFELSE([AC_LANG_SOURCE(
          [[void a(int x)
            {
              asm volatile("":::"memory");
              asm volatile("":"+r"(x)::"memory"); }]])],
          [gcry_cv_have_asm_volatile_memory=yes])])
fi
if test "$gcry_cv_have_asm_volatile_memory" = "yes" ; then
   AC_DEFINE(HAVE_GCC_ASM_VOLATILE_MEMORY,1,
     [Define if inline asm memory barrier is supported])
fi


#
# Check whether GCC assembler supports features needed for our ARM
# implementations.  This needs to be done before setting up the
# assembler stuff.
#
AC_CACHE_CHECK([whether GCC assembler is compatible for ARM assembly implementations],
       [gcry_cv_gcc_arm_platform_as_ok],
       [if test "$try_asm_modules" != "yes" ; then
          gcry_cv_gcc_arm_platform_as_ok="n/a"
        else
          gcry_cv_gcc_arm_platform_as_ok=no
          AC_LINK_IFELSE([AC_LANG_PROGRAM(
            [[__asm__(
                /* Test if assembler supports UAL syntax.  */
                ".syntax unified\n\t"
                ".arm\n\t" /* our assembly code is in ARM mode  */
                ".text\n\t"
                /* Following causes error if assembler ignored '.syntax unified'.  */
                "asmfunc:\n\t"
                "add r0, r0, r4, ror #12;\n\t"

                /* Test if '.type' and '.size' are supported.  */
                ".size asmfunc,.-asmfunc;\n\t"
                ".type asmfunc,%function;\n\t"
              );
              void asmfunc(void);]], [ asmfunc(); ] )],
            [gcry_cv_gcc_arm_platform_as_ok=yes])
        fi])
if test "$gcry_cv_gcc_arm_platform_as_ok" = "yes" ; then
   AC_DEFINE(HAVE_COMPATIBLE_GCC_ARM_PLATFORM_AS,1,
     [Defined if underlying assembler is compatible with ARM assembly implementations])
fi


#
# Check whether GCC assembler supports features needed for our ARMv8/Aarch64
# implementations.  This needs to be done before setting up the
# assembler stuff.
#
AC_CACHE_CHECK([whether GCC assembler is compatible for ARMv8/Aarch64 assembly implementations],
       [gcry_cv_gcc_aarch64_platform_as_ok],
       [if test "$try_asm_modules" != "yes" ; then
          gcry_cv_gcc_aarch64_platform_as_ok="n/a"
        else
          gcry_cv_gcc_aarch64_platform_as_ok=no
          AC_LINK_IFELSE([AC_LANG_PROGRAM(
            [[__asm__(
                ".text\n\t"
                "asmfunc:\n\t"
                "eor x0, x0, x30, ror #12;\n\t"
                "add x0, x0, x30, asr #12;\n\t"
                "eor v0.16b, v0.16b, v31.16b;\n\t"
              );
              void asmfunc(void);]], [ asmfunc(); ] )],
            [gcry_cv_gcc_aarch64_platform_as_ok=yes])
        fi])
if test "$gcry_cv_gcc_aarch64_platform_as_ok" = "yes" ; then
   AC_DEFINE(HAVE_COMPATIBLE_GCC_AARCH64_PLATFORM_AS,1,
     [Defined if underlying assembler is compatible with ARMv8/Aarch64 assembly implementations])
fi

#
# Check whether GCC assembler supports for CFI directives.
#
AC_CACHE_CHECK([whether GCC assembler supports for CFI directives],
       [gcry_cv_gcc_asm_cfi_directives],
       [gcry_cv_gcc_asm_cfi_directives=no
        AC_LINK_IFELSE([AC_LANG_PROGRAM(
          [[__asm__(
                ".text\n\t"
                "ac_test:\n\t"
                ".cfi_startproc\n\t"
                ".cfi_remember_state\n\t"
                ".cfi_adjust_cfa_offset 8\n\t"
                ".cfi_rel_offset 0, 8\n\t"
                ".cfi_def_cfa_register 1\n\t"
                ".cfi_register 2, 3\n\t"
                ".cfi_restore 2\n\t"
                ".cfi_escape 0x0f, 0x02, 0x11, 0x00\n\t"
                ".cfi_restore_state\n\t"
                ".long 0\n\t"
                ".cfi_endproc\n\t"
            );]])],
          [gcry_cv_gcc_asm_cfi_directives=yes])])
if test "$gcry_cv_gcc_asm_cfi_directives" = "yes" ; then
   AC_DEFINE(HAVE_GCC_ASM_CFI_DIRECTIVES,1,
             [Defined if underlying assembler supports for CFI directives])
fi


#
# Check whether GCC assembler supports for ELF directives.
#
AC_CACHE_CHECK([whether GCC assembler supports for ELF directives],
       [gcry_cv_gcc_asm_elf_directives],
       [gcry_cv_gcc_asm_elf_directives=no
        AC_LINK_IFELSE([AC_LANG_PROGRAM(
          [[__asm__(
                /* Test if ELF directives '.type' and '.size' are supported. */
                ".text\n\t"
                "asmfunc:\n\t"
                ".size asmfunc,.-asmfunc;\n\t"
                ".type asmfunc,STT_FUNC;\n\t"
            );]])],
          [gcry_cv_gcc_asm_elf_directives=yes])])
if test "$gcry_cv_gcc_asm_elf_directives" = "yes" ; then
   AC_DEFINE(HAVE_GCC_ASM_ELF_DIRECTIVES,1,
             [Defined if underlying assembler supports for ELF directives])
fi


#
# Check whether underscores in symbols are required.  This needs to be
# done before setting up the assembler stuff.
#
GNUPG_SYS_SYMBOL_UNDERSCORE()


#################################
####                         ####
#### Setup assembler stuff.  ####
#### Define mpi_cpu_arch.    ####
####                         ####
#################################
AC_ARG_ENABLE(mpi-path,
              AS_HELP_STRING([--enable-mpi-path=EXTRA_PATH],
              [prepend EXTRA_PATH to list of CPU specific optimizations]),
	      mpi_extra_path="$enableval",mpi_extra_path="")
AC_MSG_CHECKING(architecture and mpi assembler functions)
if test -f $srcdir/mpi/config.links ; then
    . $srcdir/mpi/config.links
    AC_CONFIG_LINKS("$mpi_ln_list")
    ac_cv_mpi_sflags="$mpi_sflags"
    AC_MSG_RESULT($mpi_cpu_arch)
else
    AC_MSG_RESULT(failed)
    AC_MSG_ERROR([mpi/config.links missing!])
fi
MPI_SFLAGS="$ac_cv_mpi_sflags"
AC_SUBST(MPI_SFLAGS)

AM_CONDITIONAL(MPI_MOD_ASM_MPIH_ADD1, test "$mpi_mod_asm_mpih_add1" = yes)
AM_CONDITIONAL(MPI_MOD_ASM_MPIH_SUB1, test "$mpi_mod_asm_mpih_sub1" = yes)
AM_CONDITIONAL(MPI_MOD_ASM_MPIH_MUL1, test "$mpi_mod_asm_mpih_mul1" = yes)
AM_CONDITIONAL(MPI_MOD_ASM_MPIH_MUL2, test "$mpi_mod_asm_mpih_mul2" = yes)
AM_CONDITIONAL(MPI_MOD_ASM_MPIH_MUL3, test "$mpi_mod_asm_mpih_mul3" = yes)
AM_CONDITIONAL(MPI_MOD_ASM_MPIH_LSHIFT, test "$mpi_mod_asm_mpih_lshift" = yes)
AM_CONDITIONAL(MPI_MOD_ASM_MPIH_RSHIFT, test "$mpi_mod_asm_mpih_rshift" = yes)
AM_CONDITIONAL(MPI_MOD_ASM_UDIV, test "$mpi_mod_asm_udiv" = yes)
AM_CONDITIONAL(MPI_MOD_ASM_UDIV_QRNND, test "$mpi_mod_asm_udiv_qrnnd" = yes)
AM_CONDITIONAL(MPI_MOD_C_MPIH_ADD1, test "$mpi_mod_c_mpih_add1" = yes)
AM_CONDITIONAL(MPI_MOD_C_MPIH_SUB1, test "$mpi_mod_c_mpih_sub1" = yes)
AM_CONDITIONAL(MPI_MOD_C_MPIH_MUL1, test "$mpi_mod_c_mpih_mul1" = yes)
AM_CONDITIONAL(MPI_MOD_C_MPIH_MUL2, test "$mpi_mod_c_mpih_mul2" = yes)
AM_CONDITIONAL(MPI_MOD_C_MPIH_MUL3, test "$mpi_mod_c_mpih_mul3" = yes)
AM_CONDITIONAL(MPI_MOD_C_MPIH_LSHIFT, test "$mpi_mod_c_mpih_lshift" = yes)
AM_CONDITIONAL(MPI_MOD_C_MPIH_RSHIFT, test "$mpi_mod_c_mpih_rshift" = yes)
AM_CONDITIONAL(MPI_MOD_C_UDIV, test "$mpi_mod_c_udiv" = yes)
AM_CONDITIONAL(MPI_MOD_C_UDIV_QRNND, test "$mpi_mod_c_udiv_qrnnd" = yes)

# Reset non applicable feature flags.
if test "$mpi_cpu_arch" != "x86" ; then
   aesnisupport="n/a"
   shaextsupport="n/a"
   pclmulsupport="n/a"
   sse41support="n/a"
   avxsupport="n/a"
   avx2support="n/a"
   avx512support="n/a"
   gfnisupport="n/a"
   padlocksupport="n/a"
   drngsupport="n/a"
fi

if test "$mpi_cpu_arch" != "arm" ; then
   if test "$mpi_cpu_arch" != "aarch64" ; then
     neonsupport="n/a"
     armcryptosupport="n/a"
     svesupport="n/a"
     sve2support="n/a"
   fi
fi

if test "$mpi_cpu_arch" != "ppc"; then
   ppccryptosupport="n/a"
fi

#############################################
####                                     ####
#### Platform specific compiler checks.  ####
####                                     ####
#############################################


# Following tests depend on warnings to cause compile to fail, so set -Werror
# temporarily.
_gcc_cflags_save=$CFLAGS
CFLAGS="$CFLAGS -Werror"


#
# Check whether compiler supports 'optimize' function attribute
#
AC_CACHE_CHECK([whether compiler supports 'optimize' function attribute],
       [gcry_cv_gcc_attribute_optimize],
       [gcry_cv_gcc_attribute_optimize=no
        AC_COMPILE_IFELSE([AC_LANG_SOURCE(
          [[int __attribute__ ((optimize("-O2"))) fn(int i){return i;}]])],
          [gcry_cv_gcc_attribute_optimize=yes])])
if test "$gcry_cv_gcc_attribute_optimize" = "yes" ; then
   AC_DEFINE(HAVE_GCC_ATTRIBUTE_OPTIMIZE,1,
     [Defined if compiler supports "__attribute__ ((optimize))" function attribute])
fi


#
# Check whether compiler supports 'ms_abi' function attribute.
#
AC_CACHE_CHECK([whether compiler supports 'ms_abi' function attribute],
       [gcry_cv_gcc_attribute_ms_abi],
       [gcry_cv_gcc_attribute_ms_abi=no
        AC_COMPILE_IFELSE([AC_LANG_SOURCE(
          [[int __attribute__ ((ms_abi)) proto(int);]])],
          [gcry_cv_gcc_attribute_ms_abi=yes])])
if test "$gcry_cv_gcc_attribute_ms_abi" = "yes" ; then
   AC_DEFINE(HAVE_GCC_ATTRIBUTE_MS_ABI,1,
     [Defined if compiler supports "__attribute__ ((ms_abi))" function attribute])
fi


#
# Check whether compiler supports 'sysv_abi' function attribute.
#
AC_CACHE_CHECK([whether compiler supports 'sysv_abi' function attribute],
       [gcry_cv_gcc_attribute_sysv_abi],
       [gcry_cv_gcc_attribute_sysv_abi=no
        AC_COMPILE_IFELSE([AC_LANG_SOURCE(
          [[int __attribute__ ((sysv_abi)) proto(int);]])],
          [gcry_cv_gcc_attribute_sysv_abi=yes])])
if test "$gcry_cv_gcc_attribute_sysv_abi" = "yes" ; then
   AC_DEFINE(HAVE_GCC_ATTRIBUTE_SYSV_ABI,1,
     [Defined if compiler supports "__attribute__ ((sysv_abi))" function attribute])
fi


#
# Check whether default calling convention is 'ms_abi'.
#
if test "$gcry_cv_gcc_attribute_ms_abi" = "yes" ; then
   AC_CACHE_CHECK([whether default calling convention is 'ms_abi'],
          [gcry_cv_gcc_default_abi_is_ms_abi],
          [gcry_cv_gcc_default_abi_is_ms_abi=no
           AC_COMPILE_IFELSE([AC_LANG_SOURCE(
             [[void *test(void) {
                 void *(*def_func)(void) = test;
                 void *__attribute__((ms_abi))(*msabi_func)(void);
                 /* warning on SysV abi targets, passes on Windows based targets */
                 msabi_func = def_func;
                 return msabi_func;
             }]])],
             [gcry_cv_gcc_default_abi_is_ms_abi=yes])])
   if test "$gcry_cv_gcc_default_abi_is_ms_abi" = "yes" ; then
      AC_DEFINE(HAVE_GCC_DEFAULT_ABI_IS_MS_ABI,1,
        [Defined if default calling convention is 'ms_abi'])
   fi
fi


#
# Check whether default calling convention is 'sysv_abi'.
#
if test "$gcry_cv_gcc_attribute_sysv_abi" = "yes" ; then
   AC_CACHE_CHECK([whether default calling convention is 'sysv_abi'],
          [gcry_cv_gcc_default_abi_is_sysv_abi],
          [gcry_cv_gcc_default_abi_is_sysv_abi=no
           AC_COMPILE_IFELSE([AC_LANG_SOURCE(
             [[void *test(void) {
                 void *(*def_func)(void) = test;
                 void *__attribute__((sysv_abi))(*sysvabi_func)(void);
                 /* warning on MS ABI targets, passes on SysV ABI targets */
                 sysvabi_func = def_func;
                 return sysvabi_func;
             }]])],
             [gcry_cv_gcc_default_abi_is_sysv_abi=yes])])
   if test "$gcry_cv_gcc_default_abi_is_sysv_abi" = "yes" ; then
      AC_DEFINE(HAVE_GCC_DEFAULT_ABI_IS_SYSV_ABI,1,
        [Defined if default calling convention is 'sysv_abi'])
   fi
fi

#
# Check whether compiler support '__thread' storage class specifier.
#
AC_CACHE_CHECK([whether compiler supports '__thread' storage class specifier],
       [gcry_cv_gcc_storage_class__thread],
       [gcry_cv_gcc_storage_class__thread=no
        AC_COMPILE_IFELSE([AC_LANG_PROGRAM(
          [[static __thread int bar;]],
          [[(void)bar;]]
          )],
          [gcry_cv_gcc_storage_class__thread=yes])])
if test "$gcry_cv_gcc_storage_class__thread" = "yes" ; then
   AC_DEFINE(HAVE_GCC_STORAGE_CLASS__THREAD,1,
     [Defined if compiler supports "__thread" storage class specifier])
fi

# Restore flags.
CFLAGS=$_gcc_cflags_save;


#
# Check whether GCC inline assembler supports SSSE3 instructions
# This is required for the AES-NI instructions.
#
AC_CACHE_CHECK([whether GCC inline assembler supports SSSE3 instructions],
       [gcry_cv_gcc_inline_asm_ssse3],
       [if test "$mpi_cpu_arch" != "x86" ||
           test "$try_asm_modules" != "yes" ; then
          gcry_cv_gcc_inline_asm_ssse3="n/a"
        else
          gcry_cv_gcc_inline_asm_ssse3=no
          AC_LINK_IFELSE([AC_LANG_PROGRAM(
          [[static unsigned char be_mask[16] __attribute__ ((aligned (16))) =
              { 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 };
            void a(void) {
              __asm__("pshufb %[mask], %%xmm2\n\t"::[mask]"m"(*be_mask):);
            }]], [ a(); ] )],
          [gcry_cv_gcc_inline_asm_ssse3=yes])
        fi])
if test "$gcry_cv_gcc_inline_asm_ssse3" = "yes" ; then
   AC_DEFINE(HAVE_GCC_INLINE_ASM_SSSE3,1,
     [Defined if inline assembler supports SSSE3 instructions])
fi


#
# Check whether GCC inline assembler supports PCLMUL instructions.
#
AC_CACHE_CHECK([whether GCC inline assembler supports PCLMUL instructions],
       [gcry_cv_gcc_inline_asm_pclmul],
       [if test "$mpi_cpu_arch" != "x86" ||
           test "$try_asm_modules" != "yes" ; then
          gcry_cv_gcc_inline_asm_pclmul="n/a"
        else
          gcry_cv_gcc_inline_asm_pclmul=no
          AC_LINK_IFELSE([AC_LANG_PROGRAM(
          [[void a(void) {
              __asm__("pclmulqdq \$0, %%xmm1, %%xmm3\n\t":::"cc");
            }]], [ a(); ] )],
          [gcry_cv_gcc_inline_asm_pclmul=yes])
        fi])
if test "$gcry_cv_gcc_inline_asm_pclmul" = "yes" ; then
   AC_DEFINE(HAVE_GCC_INLINE_ASM_PCLMUL,1,
     [Defined if inline assembler supports PCLMUL instructions])
fi


#
# Check whether GCC inline assembler supports SHA Extensions instructions.
#
AC_CACHE_CHECK([whether GCC inline assembler supports SHA Extensions instructions],
       [gcry_cv_gcc_inline_asm_shaext],
       [if test "$mpi_cpu_arch" != "x86" ||
           test "$try_asm_modules" != "yes" ; then
          gcry_cv_gcc_inline_asm_shaext="n/a"
        else
          gcry_cv_gcc_inline_asm_shaext=no
          AC_LINK_IFELSE([AC_LANG_PROGRAM(
          [[void a(void) {
              __asm__("sha1rnds4 \$0, %%xmm1, %%xmm3\n\t":::"cc");
              __asm__("sha1nexte %%xmm1, %%xmm3\n\t":::"cc");
              __asm__("sha1msg1 %%xmm1, %%xmm3\n\t":::"cc");
              __asm__("sha1msg2 %%xmm1, %%xmm3\n\t":::"cc");
              __asm__("sha256rnds2 %%xmm0, %%xmm1, %%xmm3\n\t":::"cc");
              __asm__("sha256msg1 %%xmm1, %%xmm3\n\t":::"cc");
              __asm__("sha256msg2 %%xmm1, %%xmm3\n\t":::"cc");
            }]], [ a(); ] )],
          [gcry_cv_gcc_inline_asm_shaext=yes])
        fi])
if test "$gcry_cv_gcc_inline_asm_shaext" = "yes" ; then
   AC_DEFINE(HAVE_GCC_INLINE_ASM_SHAEXT,1,
     [Defined if inline assembler supports SHA Extensions instructions])
fi


#
# Check whether GCC inline assembler supports SSE4.1 instructions.
#
AC_CACHE_CHECK([whether GCC inline assembler supports SSE4.1 instructions],
       [gcry_cv_gcc_inline_asm_sse41],
       [if test "$mpi_cpu_arch" != "x86" ||
           test "$try_asm_modules" != "yes" ; then
          gcry_cv_gcc_inline_asm_sse41="n/a"
        else
          gcry_cv_gcc_inline_asm_sse41=no
          AC_LINK_IFELSE([AC_LANG_PROGRAM(
          [[void a(void) {
              int i;
              __asm__("pextrd \$2, %%xmm0, %[out]\n\t" : [out] "=m" (i));
            }]], [ a(); ] )],
          [gcry_cv_gcc_inline_asm_sse41=yes])
        fi])
if test "$gcry_cv_gcc_inline_asm_sse41" = "yes" ; then
   AC_DEFINE(HAVE_GCC_INLINE_ASM_SSE41,1,
     [Defined if inline assembler supports SSE4.1 instructions])
fi


#
# Check whether GCC inline assembler supports AVX instructions
#
AC_CACHE_CHECK([whether GCC inline assembler supports AVX instructions],
       [gcry_cv_gcc_inline_asm_avx],
       [if test "$mpi_cpu_arch" != "x86" ||
           test "$try_asm_modules" != "yes" ; then
          gcry_cv_gcc_inline_asm_avx="n/a"
        else
          gcry_cv_gcc_inline_asm_avx=no
          AC_LINK_IFELSE([AC_LANG_PROGRAM(
          [[void a(void) {
              __asm__("xgetbv; vaesdeclast (%[mem]),%%xmm0,%%xmm7\n\t"::[mem]"r"(0):);
            }]], [ a(); ] )],
          [gcry_cv_gcc_inline_asm_avx=yes])
        fi])
if test "$gcry_cv_gcc_inline_asm_avx" = "yes" ; then
   AC_DEFINE(HAVE_GCC_INLINE_ASM_AVX,1,
     [Defined if inline assembler supports AVX instructions])
fi


#
# Check whether GCC inline assembler supports AVX2 instructions
#
AC_CACHE_CHECK([whether GCC inline assembler supports AVX2 instructions],
       [gcry_cv_gcc_inline_asm_avx2],
       [if test "$mpi_cpu_arch" != "x86" ||
           test "$try_asm_modules" != "yes" ; then
          gcry_cv_gcc_inline_asm_avx2="n/a"
        else
          gcry_cv_gcc_inline_asm_avx2=no
          AC_LINK_IFELSE([AC_LANG_PROGRAM(
          [[void a(void) {
              __asm__("xgetbv; vpbroadcastb %%xmm7,%%ymm1\n\t":::"cc");
            }]], [ a(); ] )],
          [gcry_cv_gcc_inline_asm_avx2=yes])
        fi])
if test "$gcry_cv_gcc_inline_asm_avx2" = "yes" ; then
   AC_DEFINE(HAVE_GCC_INLINE_ASM_AVX2,1,
     [Defined if inline assembler supports AVX2 instructions])
fi


#
# Check whether GCC inline assembler supports AVX512 instructions
#
AC_CACHE_CHECK([whether GCC inline assembler supports AVX512 instructions],
       [gcry_cv_gcc_inline_asm_avx512],
       [if test "$mpi_cpu_arch" != "x86" ||
           test "$try_asm_modules" != "yes" ; then
          gcry_cv_gcc_inline_asm_avx512="n/a"
        else
          gcry_cv_gcc_inline_asm_avx512=no
          AC_LINK_IFELSE([AC_LANG_PROGRAM(
          [[void a(void) {
              __asm__("xgetbv; vpopcntq %%zmm7, %%zmm1%{%%k1%}%{z%};\n\t":::"cc");
              __asm__("vpexpandb %%zmm3, %%zmm1;\n\t":::"cc");
              __asm__("vpxorq %%xmm7, %%xmm7, %%xmm7;\n\t":::"cc");
              __asm__("vpxorq %%ymm7, %%ymm7, %%ymm7;\n\t":::"cc");
              __asm__("vpxorq (%%eax)%{1to8%}, %%zmm7, %%zmm7;\n\t":::"cc");
            }]], [ a(); ] )],
          [gcry_cv_gcc_inline_asm_avx512=yes])
        fi])
if test "$gcry_cv_gcc_inline_asm_avx512" = "yes" ; then
   AC_DEFINE(HAVE_GCC_INLINE_ASM_AVX512,1,
     [Defined if inline assembler supports AVX512 instructions])
fi


#
# Check whether GCC inline assembler supports VAES and VPCLMUL instructions
#
AC_CACHE_CHECK([whether GCC inline assembler supports VAES and VPCLMUL instructions],
       [gcry_cv_gcc_inline_asm_vaes_vpclmul],
       [if test "$mpi_cpu_arch" != "x86" ||
           test "$try_asm_modules" != "yes" ; then
          gcry_cv_gcc_inline_asm_vaes_vpclmul="n/a"
        else
          gcry_cv_gcc_inline_asm_vaes_vpclmul=no
          AC_LINK_IFELSE([AC_LANG_PROGRAM(
          [[void a(void) {
              __asm__("vaesenclast %%ymm7,%%ymm7,%%ymm1\n\t":::"cc");/*256-bit*/
              __asm__("vaesenclast %%zmm7,%%zmm7,%%zmm1\n\t":::"cc");/*512-bit*/
              __asm__("vpclmulqdq \$0,%%ymm7,%%ymm7,%%ymm1\n\t":::"cc");/*256-bit*/
              __asm__("vpclmulqdq \$0,%%zmm7,%%zmm7,%%zmm1\n\t":::"cc");/*512-bit*/
            }]], [ a(); ] )],
          [gcry_cv_gcc_inline_asm_vaes_vpclmul=yes])
        fi])
if test "$gcry_cv_gcc_inline_asm_vaes_vpclmul" = "yes" ; then
   AC_DEFINE(HAVE_GCC_INLINE_ASM_VAES_VPCLMUL,1,
     [Defined if inline assembler supports VAES and VPCLMUL instructions])
fi


#
# Check whether GCC inline assembler supports GFNI instructions
#
AC_CACHE_CHECK([whether GCC inline assembler supports GFNI instructions],
       [gcry_cv_gcc_inline_asm_gfni],
       [if test "$mpi_cpu_arch" != "x86" ||
           test "$try_asm_modules" != "yes" ; then
          gcry_cv_gcc_inline_asm_gfni="n/a"
        else
          gcry_cv_gcc_inline_asm_gfni=no
          AC_LINK_IFELSE([AC_LANG_PROGRAM(
          [[void a(void) {
              __asm__("gf2p8affineqb \$123, %%xmm0, %%xmm0;\n\t":::"cc"); /* SSE */
              __asm__("vgf2p8affineinvqb \$234, %%ymm1, %%ymm1, %%ymm1;\n\t":::"cc"); /* AVX */
              __asm__("vgf2p8mulb (%%eax), %%zmm2, %%zmm2;\n\t":::"cc"); /* AVX512 */
            }]], [ a(); ] )],
          [gcry_cv_gcc_inline_asm_gfni=yes])
        fi])
if test "$gcry_cv_gcc_inline_asm_gfni" = "yes" ; then
   AC_DEFINE(HAVE_GCC_INLINE_ASM_GFNI,1,
     [Defined if inline assembler supports GFNI instructions])
fi


#
# Check whether GCC inline assembler supports BMI2 instructions
#
AC_CACHE_CHECK([whether GCC inline assembler supports BMI2 instructions],
       [gcry_cv_gcc_inline_asm_bmi2],
       [if test "$mpi_cpu_arch" != "x86" ||
           test "$try_asm_modules" != "yes" ; then
          gcry_cv_gcc_inline_asm_bmi2="n/a"
        else
          gcry_cv_gcc_inline_asm_bmi2=no
          AC_LINK_IFELSE([AC_LANG_PROGRAM(
          [[unsigned int a(unsigned int x, unsigned int y) {
              unsigned int tmp1, tmp2;
              asm ("rorxl %2, %1, %0"
                   : "=r" (tmp1)
                   : "rm0" (x), "J" (32 - ((23) & 31)));
              asm ("andnl %2, %1, %0"
                   : "=r" (tmp2)
                   : "r0" (x), "rm" (y));
              return tmp1 + tmp2;
            }]], [ a(1, 2); ] )],
          [gcry_cv_gcc_inline_asm_bmi2=yes])
        fi])
if test "$gcry_cv_gcc_inline_asm_bmi2" = "yes" ; then
   AC_DEFINE(HAVE_GCC_INLINE_ASM_BMI2,1,
     [Defined if inline assembler supports BMI2 instructions])
fi


#
# Check whether compiler supports x86/AVX512 intrinsics
#
_gcc_cflags_save=$CFLAGS
CFLAGS="$CFLAGS -mavx512f"

AC_CACHE_CHECK([whether compiler supports x86/AVX512 intrinsics],
      [gcry_cv_cc_x86_avx512_intrinsics],
      [if test "$mpi_cpu_arch" != "x86" ||
	  test "$try_asm_modules" != "yes" ; then
	gcry_cv_cc_x86_avx512_intrinsics="n/a"
      else
	gcry_cv_cc_x86_avx512_intrinsics=no
	AC_COMPILE_IFELSE([AC_LANG_SOURCE(
	[[#include <immintrin.h>
	  __m512i fn(void *in, __m128i y)
	  {
	    __m512i x;
            x = _mm512_loadu_epi32 (in); /* check the GCC bug 90980. */
	    x = _mm512_maskz_loadu_epi32(_cvtu32_mask16(0xfff0), in)
		  ^ _mm512_castsi128_si512(y);
	    asm volatile ("vinserti32x4 \$3, %0, %%zmm6, %%zmm6;\n\t"
			  "vpxord %%zmm6, %%zmm6, %%zmm6"
			  ::"x"(y),"r"(in):"memory","xmm6");
	    return x;
	  }
	  ]])],
	[gcry_cv_cc_x86_avx512_intrinsics=yes])
      fi])
if test "$gcry_cv_cc_x86_avx512_intrinsics" = "yes" ; then
    AC_DEFINE(HAVE_COMPATIBLE_CC_X86_AVX512_INTRINSICS,1,
	    [Defined if underlying compiler supports x86/AVX512 intrinsics])
fi

AM_CONDITIONAL(ENABLE_X86_AVX512_INTRINSICS_EXTRA_CFLAGS,
	       test "$gcry_cv_cc_x86_avx512_intrinsics" = "yes")

# Restore flags.
CFLAGS=$_gcc_cflags_save;


#
# Check whether GCC assembler needs "-Wa,--divide" to correctly handle
# constant division
#
if test $amd64_as_feature_detection = yes; then
  AC_CACHE_CHECK([whether GCC assembler handles division correctly],
       [gcry_cv_gcc_as_const_division_ok],
       [gcry_cv_gcc_as_const_division_ok=no
        AC_LINK_IFELSE([AC_LANG_PROGRAM(
          [[__asm__(".text\n\tfn:\n\t xorl \$(123456789/12345678), %ebp;\n\t");
            void fn(void);]],
            [fn();])],
          [gcry_cv_gcc_as_const_division_ok=yes])])
  if test "$gcry_cv_gcc_as_const_division_ok" = "no" ; then
    #
    # Add '-Wa,--divide' to CPPFLAGS and try check again.
    #
    _gcc_cppflags_save="$CPPFLAGS"
    CPPFLAGS="$CPPFLAGS -Wa,--divide"
    AC_CACHE_CHECK([whether GCC assembler handles division correctly with "-Wa,--divide"],
         [gcry_cv_gcc_as_const_division_with_wadivide_ok],
         [gcry_cv_gcc_as_const_division_with_wadivide_ok=no
          AC_LINK_IFELSE([AC_LANG_PROGRAM(
            [[__asm__(".text\n\tfn:\n\t xorl \$(123456789/12345678), %ebp;\n\t");
              void fn(void);]],
              [fn();])],
            [gcry_cv_gcc_as_const_division_with_wadivide_ok=yes])])
    if test "$gcry_cv_gcc_as_const_division_with_wadivide_ok" = "no" ; then
      # '-Wa,--divide' did not work, restore old flags.
      CPPFLAGS="$_gcc_cppflags_save"
    fi
  fi
fi


#
# Check whether GCC assembler supports features needed for our i386/amd64
# implementations
#
if test $amd64_as_feature_detection = yes; then
  AC_CACHE_CHECK([whether GCC assembler is compatible for i386/amd64 assembly implementations],
       [gcry_cv_gcc_x86_platform_as_ok],
       [if test "$mpi_cpu_arch" != "x86" ||
           test "$try_asm_modules" != "yes" ; then
          gcry_cv_gcc_x86_platform_as_ok="n/a"
        else
          gcry_cv_gcc_x86_platform_as_ok=no
          AC_LINK_IFELSE([AC_LANG_PROGRAM(
          [[__asm__(
                /* Test if '.type' and '.size' are supported.  */
                /* These work only on ELF targets. */
                ".text\n\t"
                "asmfunc:\n\t"
                ".size asmfunc,.-asmfunc;\n\t"
                ".type asmfunc,@function;\n\t"
                /* Test if assembler allows use of '/' for constant division
                 * (Solaris/x86 issue). If previous constant division check
                 * and "-Wa,--divide" workaround failed, this causes assembly
                 * to be disable on this machine. */
                 "xorl \$(123456789/12345678), %ebp;\n\t"
            );
            void asmfunc(void);]], [ asmfunc(); ])],
          [gcry_cv_gcc_x86_platform_as_ok=yes])
        fi])
  if test "$gcry_cv_gcc_x86_platform_as_ok" = "yes" &&
     test "$ac_cv_sizeof_unsigned_long" = "8"; then
    AC_DEFINE(HAVE_COMPATIBLE_GCC_AMD64_PLATFORM_AS,1,
              [Defined if underlying assembler is compatible with amd64 assembly implementations])
  fi
  if test "$gcry_cv_gcc_x86_platform_as_ok" = "yes" &&
     test "$ac_cv_sizeof_unsigned_long" = "4"; then
    AC_DEFINE(HAVE_COMPATIBLE_GCC_I386_PLATFORM_AS,1,
              [Defined if underlying assembler is compatible with i386 assembly implementations])
  fi
  if test "$gcry_cv_gcc_x86_platform_as_ok" = "no" &&
     test "$gcry_cv_gcc_attribute_sysv_abi" = "yes" &&
     test "$gcry_cv_gcc_default_abi_is_ms_abi" = "yes"; then
    AC_CACHE_CHECK([whether GCC assembler is compatible for WIN64 assembly implementations],
      [gcry_cv_gcc_win64_platform_as_ok],
      [gcry_cv_gcc_win64_platform_as_ok=no
      AC_LINK_IFELSE([AC_LANG_PROGRAM(
        [[__asm__(
              ".text\n\t"
              ".globl asmfunc\n\t"
              "asmfunc:\n\t"
              "xorq \$(1234), %rbp;\n\t"
          );
          void asmfunc(void);]], [ asmfunc(); ])],
        [gcry_cv_gcc_win64_platform_as_ok=yes])])
    if test "$gcry_cv_gcc_win64_platform_as_ok" = "yes" ; then
      AC_DEFINE(HAVE_COMPATIBLE_GCC_WIN64_PLATFORM_AS,1,
                [Defined if underlying assembler is compatible with WIN64 assembly implementations])
    fi
  fi
  if test "$gcry_cv_gcc_x86_platform_as_ok" = "no" &&
     test "$ac_cv_sizeof_unsigned_long" = "4"; then
    AC_CACHE_CHECK([whether GCC assembler is compatible for WIN32 assembly implementations],
      [gcry_cv_gcc_win32_platform_as_ok],
      [gcry_cv_gcc_win32_platform_as_ok=no
      AC_LINK_IFELSE([AC_LANG_PROGRAM(
        [[__asm__(
              ".text\n\t"
              ".globl _asmfunc\n\t"
              "_asmfunc:\n\t"
              "xorl \$(1234), %ebp;\n\t"
          );
          void asmfunc(void);]], [ asmfunc(); ])],
        [gcry_cv_gcc_win32_platform_as_ok=yes])])
    if test "$gcry_cv_gcc_win32_platform_as_ok" = "yes" ; then
      AC_DEFINE(HAVE_COMPATIBLE_GCC_WIN32_PLATFORM_AS,1,
                [Defined if underlying assembler is compatible with WIN32 assembly implementations])
    fi
  fi
fi


#
# Check whether GCC assembler supports features needed for assembly
# implementations that use Intel syntax
#
AC_CACHE_CHECK([whether GCC assembler is compatible for Intel syntax assembly implementations],
       [gcry_cv_gcc_platform_as_ok_for_intel_syntax],
       [if test "$mpi_cpu_arch" != "x86" ||
           test "$try_asm_modules" != "yes" ; then
          gcry_cv_gcc_platform_as_ok_for_intel_syntax="n/a"
        else
          gcry_cv_gcc_platform_as_ok_for_intel_syntax=no
          AC_LINK_IFELSE([AC_LANG_PROGRAM(
          [[__asm__(
                ".intel_syntax noprefix\n\t"
                ".text\n\t"
                "actest:\n\t"
                "pxor xmm1, xmm7;\n\t"
                "vperm2i128 ymm2, ymm3, ymm0, 1;\n\t"
                "add eax, ebp;\n\t"
                "rorx eax, ebp, 1;\n\t"
                "sub eax, [esp + 4];\n\t"
                "add dword ptr [esp + eax], 0b10101;\n\t"
                ".att_syntax prefix\n\t"
            );
            void actest(void);]], [ actest(); ])],
          [gcry_cv_gcc_platform_as_ok_for_intel_syntax=yes])
        fi])
if test "$gcry_cv_gcc_platform_as_ok_for_intel_syntax" = "yes" ; then
  AC_DEFINE(HAVE_INTEL_SYNTAX_PLATFORM_AS,1,
            [Defined if underlying assembler is compatible with Intel syntax assembly implementations])
fi


#
# Check whether compiler is configured for ARMv6 or newer architecture
#
AC_CACHE_CHECK([whether compiler is configured for ARMv6 or newer architecture],
       [gcry_cv_cc_arm_arch_is_v6],
       [if test "$mpi_cpu_arch" != "arm" ||
           test "$try_asm_modules" != "yes" ; then
          gcry_cv_cc_arm_arch_is_v6="n/a"
        else
          gcry_cv_cc_arm_arch_is_v6=no
          AC_COMPILE_IFELSE([AC_LANG_SOURCE(
          [[
           #if defined(__arm__) && \
             ((defined(__ARM_ARCH) && __ARM_ARCH >= 6) \
             || defined(__ARM_ARCH_6__) || defined(__ARM_ARCH_6J__) \
             || defined(__ARM_ARCH_6Z__) || defined(__ARM_ARCH_6ZK__) \
             || defined(__ARM_ARCH_6K__) || defined(__ARM_ARCH_6T2__) \
             || defined(__ARM_ARCH_7__) || defined(__ARM_ARCH_7A__) \
             || defined(__ARM_ARCH_7R__) || defined(__ARM_ARCH_7M__) \
             || defined(__ARM_ARCH_7EM__))
             /* empty */
           #else
             /* fail compile if not ARMv6. */
             not_armv6 not_armv6 = (not_armv6)not_armv6;
           #endif
          ]])],
          [gcry_cv_cc_arm_arch_is_v6=yes])
        fi])
if test "$gcry_cv_cc_arm_arch_is_v6" = "yes" ; then
   AC_DEFINE(HAVE_ARM_ARCH_V6,1,
     [Defined if ARM architecture is v6 or newer])
fi


#
# Check whether GCC inline assembler supports NEON instructions
#
AC_CACHE_CHECK([whether GCC inline assembler supports NEON instructions],
       [gcry_cv_gcc_inline_asm_neon],
       [if test "$mpi_cpu_arch" != "arm" ||
           test "$try_asm_modules" != "yes" ; then
          gcry_cv_gcc_inline_asm_neon="n/a"
        else
          gcry_cv_gcc_inline_asm_neon=no
          AC_LINK_IFELSE([AC_LANG_PROGRAM(
          [[__asm__(
                ".syntax unified\n\t"
                ".arm\n\t"
                ".fpu neon\n\t"
                ".text\n\t"
                "testfn:\n\t"
                "vld1.64 {q0-q1}, [r0]!;\n\t"
                "vrev64.8 q0, q3;\n\t"
                "vadd.u64 q0, q1;\n\t"
                "vadd.s64 d3, d2, d3;\n\t"
                );
            void testfn(void);
            ]], [ testfn(); ])],
          [gcry_cv_gcc_inline_asm_neon=yes])
        fi])
if test "$gcry_cv_gcc_inline_asm_neon" = "yes" ; then
   AC_DEFINE(HAVE_GCC_INLINE_ASM_NEON,1,
     [Defined if inline assembler supports NEON instructions])
fi


#
# Check whether GCC inline assembler supports AArch32 Crypto Extension instructions
#
AC_CACHE_CHECK([whether GCC inline assembler supports AArch32 Crypto Extension instructions],
       [gcry_cv_gcc_inline_asm_aarch32_crypto],
       [if test "$mpi_cpu_arch" != "arm" ||
           test "$try_asm_modules" != "yes" ; then
          gcry_cv_gcc_inline_asm_aarch32_crypto="n/a"
        else
          gcry_cv_gcc_inline_asm_aarch32_crypto=no
          AC_LINK_IFELSE([AC_LANG_PROGRAM(
          [[__asm__(
                ".syntax unified\n\t"
                ".arch armv8-a\n\t"
                ".arm\n\t"
                ".fpu crypto-neon-fp-armv8\n\t"
                ".text\n\t"

                "testfn:\n\t"
                "sha1h.32 q0, q0;\n\t"
                "sha1c.32 q0, q0, q0;\n\t"
                "sha1p.32 q0, q0, q0;\n\t"
                "sha1su0.32 q0, q0, q0;\n\t"
                "sha1su1.32 q0, q0;\n\t"

                "sha256h.32 q0, q0, q0;\n\t"
                "sha256h2.32 q0, q0, q0;\n\t"
                "sha1p.32 q0, q0, q0;\n\t"
                "sha256su0.32 q0, q0;\n\t"
                "sha256su1.32 q0, q0, q15;\n\t"

                "aese.8 q0, q0;\n\t"
                "aesd.8 q0, q0;\n\t"
                "aesmc.8 q0, q0;\n\t"
                "aesimc.8 q0, q0;\n\t"

                "vmull.p64 q0, d0, d0;\n\t"
                );
            void testfn(void);
            ]], [ testfn(); ])],
          [gcry_cv_gcc_inline_asm_aarch32_crypto=yes])
        fi])
if test "$gcry_cv_gcc_inline_asm_aarch32_crypto" = "yes" ; then
   AC_DEFINE(HAVE_GCC_INLINE_ASM_AARCH32_CRYPTO,1,
     [Defined if inline assembler supports AArch32 Crypto Extension instructions])
fi


#
# Check whether GCC inline assembler supports AArch64 NEON instructions
#
AC_CACHE_CHECK([whether GCC inline assembler supports AArch64 NEON instructions],
       [gcry_cv_gcc_inline_asm_aarch64_neon],
       [if test "$mpi_cpu_arch" != "aarch64" ||
           test "$try_asm_modules" != "yes" ; then
          gcry_cv_gcc_inline_asm_aarch64_neon="n/a"
        else
          gcry_cv_gcc_inline_asm_aarch64_neon=no
          AC_LINK_IFELSE([AC_LANG_PROGRAM(
          [[__asm__(
                ".cpu generic+simd\n\t"
                ".text\n\t"
                "testfn:\n\t"
                "mov w0, \#42;\n\t"
                "dup v0.8b, w0;\n\t"
                "ld4 {v0.8b,v1.8b,v2.8b,v3.8b},[x0],\#32;\n\t"
                );
            void testfn(void);
            ]], [ testfn(); ])],
          [gcry_cv_gcc_inline_asm_aarch64_neon=yes])
        fi])
if test "$gcry_cv_gcc_inline_asm_aarch64_neon" = "yes" ; then
   AC_DEFINE(HAVE_GCC_INLINE_ASM_AARCH64_NEON,1,
     [Defined if inline assembler supports AArch64 NEON instructions])
fi


#
# Check whether GCC inline assembler supports AArch64 Crypto Extension instructions
#
AC_CACHE_CHECK([whether GCC inline assembler supports AArch64 Crypto Extension instructions],
       [gcry_cv_gcc_inline_asm_aarch64_crypto],
       [if test "$mpi_cpu_arch" != "aarch64" ||
           test "$try_asm_modules" != "yes" ; then
          gcry_cv_gcc_inline_asm_aarch64_crypto="n/a"
        else
          gcry_cv_gcc_inline_asm_aarch64_crypto=no
          AC_LINK_IFELSE([AC_LANG_PROGRAM(
          [[__asm__(
                ".cpu generic+simd+crypto\n\t"
                ".text\n\t"
                "testfn:\n\t"
                "mov w0, \#42;\n\t"
                "dup v0.8b, w0;\n\t"
                "ld4 {v0.8b,v1.8b,v2.8b,v3.8b},[x0],\#32;\n\t"

                "sha1h s0, s0;\n\t"
                "sha1c q0, s0, v0.4s;\n\t"
                "sha1p q0, s0, v0.4s;\n\t"
                "sha1su0 v0.4s, v0.4s, v0.4s;\n\t"
                "sha1su1 v0.4s, v0.4s;\n\t"

                "sha256h q0, q0, v0.4s;\n\t"
                "sha256h2 q0, q0, v0.4s;\n\t"
                "sha1p q0, s0, v0.4s;\n\t"
                "sha256su0 v0.4s, v0.4s;\n\t"
                "sha256su1 v0.4s, v0.4s, v31.4s;\n\t"

                "aese v0.16b, v0.16b;\n\t"
                "aesd v0.16b, v0.16b;\n\t"
                "aesmc v0.16b, v0.16b;\n\t"
                "aesimc v0.16b, v0.16b;\n\t"

                "pmull v0.1q, v0.1d, v31.1d;\n\t"
                "pmull2 v0.1q, v0.2d, v31.2d;\n\t"
                );
            void testfn(void);
            ]], [ testfn(); ])],
          [gcry_cv_gcc_inline_asm_aarch64_crypto=yes])
        fi])
if test "$gcry_cv_gcc_inline_asm_aarch64_crypto" = "yes" ; then
   AC_DEFINE(HAVE_GCC_INLINE_ASM_AARCH64_CRYPTO,1,
     [Defined if inline assembler supports AArch64 Crypto Extension instructions])
fi


#
# Check whether GCC inline assembler supports AArch64 SVE instructions
#
AC_CACHE_CHECK([whether GCC inline assembler supports AArch64 SVE instructions],
       [gcry_cv_gcc_inline_asm_aarch64_sve],
       [if test "$mpi_cpu_arch" != "aarch64" ||
           test "$try_asm_modules" != "yes" ; then
          gcry_cv_gcc_inline_asm_aarch64_sve="n/a"
        else
          gcry_cv_gcc_inline_asm_aarch64_sve=no
          AC_LINK_IFELSE([AC_LANG_PROGRAM(
          [[__asm__(
                ".cpu generic+simd+sve\n\t"
                ".text\n\t"
                "testfn:\n\t"
                "mov x0, \#60;\n\t"
                "whilelo p0.s, xzr, x0;\n\t"
                "mov z0.s, p0/z, \#55;\n\t"
                "ld1b {z0.b}, p0/z, [x1];\n\t"
                );
            void testfn(void);
            ]], [ testfn(); ])],
          [gcry_cv_gcc_inline_asm_aarch64_sve=yes])
        fi])
if test "$gcry_cv_gcc_inline_asm_aarch64_sve" = "yes" ; then
   AC_DEFINE(HAVE_GCC_INLINE_ASM_AARCH64_SVE,1,
     [Defined if inline assembler supports AArch64 SVE instructions])
fi


#
# Check whether GCC inline assembler supports AArch64 SVE2 instructions
#
AC_CACHE_CHECK([whether GCC inline assembler supports AArch64 SVE2 instructions],
       [gcry_cv_gcc_inline_asm_aarch64_sve2],
       [if test "$mpi_cpu_arch" != "aarch64" ||
           test "$try_asm_modules" != "yes" ; then
          gcry_cv_gcc_inline_asm_aarch64_sve2="n/a"
        else
          gcry_cv_gcc_inline_asm_aarch64_sve2=no
          AC_LINK_IFELSE([AC_LANG_PROGRAM(
          [[__asm__(
                ".cpu generic+simd+sve2\n\t"
                ".text\n\t"
                "testfn:\n\t"
                ";\n\t"
                "eor3 z0.d, z0.d, z1.d, z2.d;\n\t"
                "ext z8.b, {z20.b, z21.b}, \#3;\n\t"
                "adclt z0.d, z1.d, z2.d;\n\t"
                "tbl z0.b, {z8.b, z9.b}, z1.b;\n\t"
                "addhnb z16.s, z17.d, z18.d;\n\t"
                "mov z0.s, p0/z, \#55;\n\t"
                "ld1b {z0.b}, p0/z, [x1];\n\t"
                );
            void testfn(void);
            ]], [ testfn(); ])],
          [gcry_cv_gcc_inline_asm_aarch64_sve2=yes])
        fi])
if test "$gcry_cv_gcc_inline_asm_aarch64_sve2" = "yes" ; then
   AC_DEFINE(HAVE_GCC_INLINE_ASM_AARCH64_SVE2,1,
     [Defined if inline assembler supports AArch64 SVE2 instructions])
fi


#
# Check whether GCC inline assembler supports AArch64 SHA3/SHA512/SM3/SM4 instructions
#
AC_CACHE_CHECK([whether GCC inline assembler supports AArch64 SHA3/SHA512/SM3/SM4 instructions],
       [gcry_cv_gcc_inline_asm_aarch64_sha3_sha512_sm3_sm4],
       [if test "$mpi_cpu_arch" != "aarch64" ||
           test "$try_asm_modules" != "yes" ; then
          gcry_cv_gcc_inline_asm_aarch64_sha3_sha512_sm3_sm4="n/a"
        else
          gcry_cv_gcc_inline_asm_aarch64_sha3_sha512_sm3_sm4=no
          AC_LINK_IFELSE([AC_LANG_PROGRAM(
          [[__asm__(
                ".arch armv8.2-a+sha3+sm4\n\t"
                ".text\n\t"
                "testfn:\n\t"

                /* Test for SHA512 instructions */
                "sha512h q0, q0, v0.2d;\n\t"
                "sha512h2 q0, q0, v0.2d;\n\t"
                "sha512su0 v0.2d, v0.2d;\n\t"
                "sha512su1 v0.2d, v0.2d, v31.2d;\n\t"

                /* Test for SHA3 instructions */
                "bcax v0.16b, v1.16b, v2.16b, v3.16b;\n\t"
                "eor3 v0.16b, v1.16b, v2.16b, v3.16b;\n\t"
                "rax1 v0.2d, v1.2d, v2.2d;\n\t"
                "xar v0.2d, v1.2d, v2.2d, \#1;\n\t"

                /* Test for SM3 instructions */
                "sm3partw1 v0.4s, v1.4s, v2.4s;\n\t"
                "sm3partw2 v0.4s, v1.4s, v2.4s;\n\t"
                "sm3ss1 v0.4s, v1.4s, v2.4s, v3.4s;\n\t"
                "sm3tt1a v0.4s, v1.4s, v2.s[0];\n\t"
                "sm3tt1b v0.4s, v1.4s, v2.s[0];\n\t"
                "sm3tt2a v0.4s, v1.4s, v2.s[0];\n\t"
                "sm3tt2b v0.4s, v1.4s, v2.s[0];\n\t"

                /* Test for SM4 instructions */
                "sm4e v0.4s, v1.4s;\n\t"
                "sm4ekey v0.4s, v1.4s, v2.4s;\n\t"
                );
            void testfn(void);
            ]], [ testfn(); ])],
          [gcry_cv_gcc_inline_asm_aarch64_sha3_sha512_sm3_sm4=yes])
        fi])
if test "$gcry_cv_gcc_inline_asm_aarch64_sha3_sha512_sm3_sm4" = "yes" ; then
   AC_DEFINE(HAVE_GCC_INLINE_ASM_AARCH64_SHA3_SHA512_SM3_SM4,1,
     [Defined if inline assembler supports AArch64 SHA3/SHA512/SM3/SM4 instructions])
fi


#
# Check whether compiler supports AArch64/NEON/crypto intrinsics
#
AC_CACHE_CHECK([whether compiler supports AArch64/NEON/crypto intrinsics],
      [gcry_cv_cc_aarch64_neon_intrinsics],
      [if test "$mpi_cpu_arch" != "aarch64" ||
	  test "$try_asm_modules" != "yes" ; then
	gcry_cv_cc_aarch64_neon_intrinsics="n/a"
      else
	gcry_cv_cc_aarch64_neon_intrinsics=no
	AC_COMPILE_IFELSE([AC_LANG_SOURCE(
	[[#include <arm_neon.h>
	  #define __m128i uint64x2_t
	  #define vpsrldq128(s, a, o) \
	    ({ uint64x2_t __tmp = { 0, 0 }; \
		o = (__m128i)vextq_u8((uint8x16_t)a, \
				      (uint8x16_t)__tmp, (s) & 15); })
	  #define vaesenclast128(a, b, o) \
	    (o = (__m128i)vaeseq_u8((uint8x16_t)b, (uint8x16_t)a))
	  #define memory_barrier_with_vec(a) __asm__("" : "+w"(a) :: "memory")
	  static inline __attribute__((always_inline)) __m128i
	  fn2(__m128i a)
	  {
	    vpsrldq128(2, a, a);
	    return a;
	  }
	  __m128i fn(__m128i in)
	  {
	    __m128i x;
	    memory_barrier_with_vec(in);
	    x = fn2(in);
	    memory_barrier_with_vec(x);
	    vaesenclast128(in, x, in);
	    memory_barrier_with_vec(in);
	    return in;
	  }
	  ]])],
	[gcry_cv_cc_aarch64_neon_intrinsics=yes])
      fi])
if test "$gcry_cv_cc_aarch64_neon_intrinsics" = "yes" ; then
    AC_DEFINE(HAVE_COMPATIBLE_CC_AARCH64_NEON_INTRINSICS,1,
	    [Defined if underlying compiler supports AArch64/NEON/crypto intrinsics])
fi

_gcc_cflags_save=$CFLAGS
CFLAGS="$CFLAGS -O2 -march=armv8-a+crypto"

if test "$gcry_cv_cc_aarch64_neon_intrinsics" = "no" &&
   test "$mpi_cpu_arch" = "aarch64" &&
   test "$try_asm_modules" = "yes" ; then
  AC_CACHE_CHECK([whether compiler supports AArch64/NEON/crypto intrinsics with extra GCC flags],
    [gcry_cv_cc_aarch64_neon_intrinsics_cflags],
    [gcry_cv_cc_aarch64_neon_intrinsics_cflags=no
    AC_COMPILE_IFELSE([AC_LANG_SOURCE(
      [[#include <arm_neon.h>
	#define __m128i uint64x2_t
	#define vpsrldq128(s, a, o) \
	  ({ uint64x2_t __tmp = { 0, 0 }; \
	      o = (__m128i)vextq_u8((uint8x16_t)a, \
				    (uint8x16_t)__tmp, (s) & 15); })
	#define vaesenclast128(a, b, o) \
	  (o = (__m128i)vaeseq_u8((uint8x16_t)b, (uint8x16_t)a))
	#define memory_barrier_with_vec(a) __asm__("" : "+w"(a) :: "memory")
	static inline __attribute__((always_inline)) __m128i
	fn2(__m128i a)
	{
	  vpsrldq128(2, a, a);
	  return a;
	}
	__m128i fn(__m128i in)
	{
	  __m128i x;
	  memory_barrier_with_vec(in);
	  x = fn2(in);
	  memory_barrier_with_vec(x);
	  vaesenclast128(in, x, in);
	  memory_barrier_with_vec(in);
	  return in;
	}
	]])],
      [gcry_cv_cc_aarch64_neon_intrinsics_cflags=yes])])
  if test "$gcry_cv_cc_aarch64_neon_intrinsics_cflags" = "yes" ; then
    AC_DEFINE(HAVE_COMPATIBLE_CC_AARCH64_NEON_INTRINSICS,1,
	      [Defined if underlying compiler supports AArch64/NEON/crypto intrinsics])
    AC_DEFINE(HAVE_COMPATIBLE_CC_AARCH64_NEON_INTRINSICS_WITH_CFLAGS,1,
	      [Defined if underlying compiler supports AArch64/NEON/crypto intrinsics with extra GCC flags])
  fi
fi

AM_CONDITIONAL(ENABLE_AARCH64_NEON_INTRINSICS_EXTRA_CFLAGS,
	       test "$gcry_cv_cc_aarch64_neon_intrinsics_cflags" = "yes")

# Restore flags.
CFLAGS=$_gcc_cflags_save;


#
# Check whether compiler supports PowerPC AltiVec/VSX intrinsics
#
AC_CACHE_CHECK([whether compiler supports PowerPC AltiVec/VSX/crypto intrinsics],
      [gcry_cv_cc_ppc_altivec],
      [if test "$mpi_cpu_arch" != "ppc" ||
	  test "$try_asm_modules" != "yes" ; then
	gcry_cv_cc_ppc_altivec="n/a"
      else
	gcry_cv_cc_ppc_altivec=no
	AC_COMPILE_IFELSE([AC_LANG_SOURCE(
	[[#include <altivec.h>
	  typedef vector unsigned char block;
	  typedef vector unsigned int vecu32;
	  static inline __attribute__((always_inline)) vecu32
	  vec_sld_u32(vecu32 a, vecu32 b, unsigned int idx)
	  {
	    return vec_sld (a, b, (4 * idx) & 15);
	  }
	  block fn(block in)
	  {
	    block t = vec_perm (in, in, vec_vsx_ld (0, (unsigned char*)0));
	    vecu32 y = vec_vsx_ld (0, (unsigned int*)0);
	    y = vec_sld_u32 (y, y, 3);
	    return vec_cipher_be (t, in) ^ (block)y;
	  }
	  ]])],
	[gcry_cv_cc_ppc_altivec=yes])
      fi])
if test "$gcry_cv_cc_ppc_altivec" = "yes" ; then
    AC_DEFINE(HAVE_COMPATIBLE_CC_PPC_ALTIVEC,1,
	    [Defined if underlying compiler supports PowerPC AltiVec/VSX/crypto intrinsics])
fi

_gcc_cflags_save=$CFLAGS
CFLAGS="$CFLAGS -O2 -maltivec -mvsx -mcrypto"

if test "$gcry_cv_cc_ppc_altivec" = "no" &&
   test "$mpi_cpu_arch" = "ppc" &&
   test "$try_asm_modules" = "yes" ; then
  AC_CACHE_CHECK([whether compiler supports PowerPC AltiVec/VSX/crypto intrinsics with extra GCC flags],
    [gcry_cv_cc_ppc_altivec_cflags],
    [gcry_cv_cc_ppc_altivec_cflags=no
    AC_COMPILE_IFELSE([AC_LANG_SOURCE(
      [[#include <altivec.h>
	typedef vector unsigned char block;
	typedef vector unsigned int vecu32;
	static inline __attribute__((always_inline)) vecu32
	vec_sld_u32(vecu32 a, vecu32 b, unsigned int idx)
	{
	  return vec_sld (a, b, (4 * idx) & 15);
	}
	block fn(block in)
	{
	  block t = vec_perm (in, in, vec_vsx_ld (0, (unsigned char*)0));
	  vecu32 y = vec_vsx_ld (0, (unsigned int*)0);
	  y = vec_sld_u32 (y, y, 3);
	  return vec_cipher_be (t, in) ^ (block)y;
	}
	]])],
      [gcry_cv_cc_ppc_altivec_cflags=yes])])
  if test "$gcry_cv_cc_ppc_altivec_cflags" = "yes" ; then
    AC_DEFINE(HAVE_COMPATIBLE_CC_PPC_ALTIVEC,1,
	      [Defined if underlying compiler supports PowerPC AltiVec/VSX/crypto intrinsics])
    AC_DEFINE(HAVE_COMPATIBLE_CC_PPC_ALTIVEC_WITH_CFLAGS,1,
	      [Defined if underlying compiler supports PowerPC AltiVec/VSX/crypto intrinsics with extra GCC flags])
  fi
fi

AM_CONDITIONAL(ENABLE_PPC_VCRYPTO_EXTRA_CFLAGS,
	       test "$gcry_cv_cc_ppc_altivec_cflags" = "yes")

# Restore flags.
CFLAGS=$_gcc_cflags_save;


#
# Check whether GCC inline assembler supports PowerPC AltiVec/VSX/crypto instructions
#
AC_CACHE_CHECK([whether GCC inline assembler supports PowerPC AltiVec/VSX/crypto instructions],
       [gcry_cv_gcc_inline_asm_ppc_altivec],
       [if test "$mpi_cpu_arch" != "ppc" ||
           test "$try_asm_modules" != "yes" ; then
          gcry_cv_gcc_inline_asm_ppc_altivec="n/a"
        else
          gcry_cv_gcc_inline_asm_ppc_altivec=no
          AC_LINK_IFELSE([AC_LANG_PROGRAM(
          [[__asm__(".globl testfn;\n"
                    ".text\n\t"
                    "testfn:\n"
                    "stvx %v31,%r12,%r0;\n"
                    "lvx  %v20,%r12,%r0;\n"
                    "vcipher %v0, %v1, %v22;\n"
                    "lxvw4x %vs32, %r0, %r1;\n"
                    "vadduwm %v0, %v1, %v22;\n"
                    "vshasigmaw %v0, %v1, 0, 15;\n"
                    "vshasigmad %v0, %v1, 0, 15;\n"
                    "vpmsumd %v11, %v11, %v11;\n"
                  );
            void testfn(void);
            ]], [ testfn(); ] )],
          [gcry_cv_gcc_inline_asm_ppc_altivec=yes])
        fi])
if test "$gcry_cv_gcc_inline_asm_ppc_altivec" = "yes" ; then
   AC_DEFINE(HAVE_GCC_INLINE_ASM_PPC_ALTIVEC,1,
     [Defined if inline assembler supports PowerPC AltiVec/VSX/crypto instructions])
fi


#
# Check whether GCC inline assembler supports PowerISA 3.00 instructions
#
AC_CACHE_CHECK([whether GCC inline assembler supports PowerISA 3.00 instructions],
       [gcry_cv_gcc_inline_asm_ppc_arch_3_00],
       [if test "$mpi_cpu_arch" != "ppc" ||
           test "$try_asm_modules" != "yes" ; then
          gcry_cv_gcc_inline_asm_ppc_arch_3_00="n/a"
        else
          gcry_cv_gcc_inline_asm_ppc_arch_3_00=no
          AC_LINK_IFELSE([AC_LANG_PROGRAM(
          [[__asm__(".text\n\t"
                    ".globl testfn;\n"
                    "testfn:\n"
                    "stxvb16x %r1,%v12,%v30;\n"
                  );
            void testfn(void);
            ]], [ testfn(); ])],
          [gcry_cv_gcc_inline_asm_ppc_arch_3_00=yes])
        fi])
if test "$gcry_cv_gcc_inline_asm_ppc_arch_3_00" = "yes" ; then
   AC_DEFINE(HAVE_GCC_INLINE_ASM_PPC_ARCH_3_00,1,
     [Defined if inline assembler supports PowerISA 3.00 instructions])
fi


#
# Check whether compiler supports GCC PowerPC target attributes
#
AC_CACHE_CHECK([whether compiler supports GCC PowerPC target attributes],
       [gcry_cv_gcc_attribute_ppc_target],
       [if test "$mpi_cpu_arch" != "ppc" ; then
          gcry_cv_gcc_attribute_ppc_target="n/a"
        else
          gcry_cv_gcc_attribute_ppc_target=no
          AC_LINK_IFELSE([AC_LANG_PROGRAM(
          [[void __attribute__((always_inline)) inline aifn(void) {}
            void __attribute__((target("cpu=power8"))) testfn8(void) {aifn();}
            void __attribute__((target("cpu=power9"))) testfn9(void)
            { testfn8(); aifn(); }
            ]], [ testfn9(); aifn(); ])],
          [gcry_cv_gcc_attribute_ppc_target=yes])
        fi])
if test "$gcry_cv_gcc_attribute_ppc_target" = "yes" ; then
   AC_DEFINE(HAVE_GCC_ATTRIBUTE_PPC_TARGET,1,
     [Defined if compiler supports GCC PowerPC target attributes])
fi


#
# Check whether compiler supports clang PowerPC target attributes
#
AC_CACHE_CHECK([whether compiler supports clang PowerPC target attributes],
       [gcry_cv_clang_attribute_ppc_target],
       [if test "$mpi_cpu_arch" != "ppc" ; then
          gcry_cv_clang_attribute_ppc_target="n/a"
        else
          gcry_cv_clang_attribute_ppc_target=no
          AC_LINK_IFELSE([AC_LANG_PROGRAM(
          [[void __attribute__((always_inline)) inline aifn(void) {}
            void __attribute__((target("arch=pwr8"))) testfn8(void) {aifn();}
            void __attribute__((target("arch=pwr9"))) testfn9(void)
            { testfn8(); aifn(); }
            ]], [ testfn9(); aifn(); ])],
          [gcry_cv_clang_attribute_ppc_target=yes])
        fi])
if test "$gcry_cv_clang_attribute_ppc_target" = "yes" ; then
   AC_DEFINE(HAVE_CLANG_ATTRIBUTE_PPC_TARGET,1,
     [Defined if compiler supports clang PowerPC target attributes])
fi


#
# Check whether GCC inline assembler supports zSeries instructions
#
AC_CACHE_CHECK([whether GCC inline assembler supports zSeries instructions],
      [gcry_cv_gcc_inline_asm_s390x],
      [if test "$mpi_cpu_arch" != "s390x" ||
	  test "$try_asm_modules" != "yes" ; then
	  gcry_cv_gcc_inline_asm_s390x="n/a"
	else
	  gcry_cv_gcc_inline_asm_s390x=no
	  AC_LINK_IFELSE([AC_LANG_PROGRAM(
	  [[typedef unsigned int u128_t __attribute__ ((mode (TI)));
	    unsigned int testfunc(unsigned int x, void *y, unsigned int z)
	    {
	      unsigned long fac[8];
	      register unsigned long reg0 asm("0") = 0;
	      register unsigned long reg1 asm("1") = x;
	      u128_t r1 = ((u128_t)(unsigned long)y << 64) | (unsigned long)z;
	      u128_t r2 = 0;
	      u128_t r3 = 0;
	      asm volatile (".insn rre,0xb92e << 16, %[r1], %[r2]\n\t"
			    : [r1] "+a" (r1), [r2] "+a" (r2)
			    : "r" (reg0), "r" (reg1)
			    : "cc", "memory");
	      asm volatile (".insn rrf,0xb929 << 16, %[r1], %[r2], %[r3], 0\n\t"
			    : [r1] "+a" (r1), [r2] "+a" (r2), [r3] "+a" (r3)
			    : "r" (reg0), "r" (reg1)
			    : "cc", "memory");
	      reg0 = 8 - 1;
	      asm ("stfle %1\n\t"
	           : "+d" (reg0), "=Q" (fac[0])
	           :
	           : "cc", "memory");
	      asm volatile ("mvc 0(16, %0), 0(%1)\n\t"
			    :
			    : "a" (y), "a" (fac)
			    : "memory");
	      asm volatile ("xc 0(16, %0), 0(%0)\n\t"
			    :
			    : "a" (fac)
			    : "memory");
	      asm volatile ("risbgn %%r11, %%r11, 0, 129, 0\n\t"
			    :
			    :
			    : "memory", "r11");
	      asm volatile ("algrk %%r14, %%r14, %%r14\n\t"
			    :
			    :
			    : "memory", "r14");
	      return (unsigned int)r1 ^ reg0;
	    }
	    ]] , [ testfunc(0, 0, 0); ])],
	  [gcry_cv_gcc_inline_asm_s390x=yes])
	fi])
if test "$gcry_cv_gcc_inline_asm_s390x" = "yes" ; then
   AC_DEFINE(HAVE_GCC_INLINE_ASM_S390X,1,
     [Defined if inline assembler supports zSeries instructions])
fi


#
# Check whether GCC inline assembler supports zSeries vector instructions
#
AC_CACHE_CHECK([whether GCC inline assembler supports zSeries vector instructions],
      [gcry_cv_gcc_inline_asm_s390x_vx],
      [if test "$mpi_cpu_arch" != "s390x" ||
	  test "$try_asm_modules" != "yes" ; then
	  gcry_cv_gcc_inline_asm_s390x_vx="n/a"
	else
	  gcry_cv_gcc_inline_asm_s390x_vx=no
	  if test "$gcry_cv_gcc_inline_asm_s390x" = "yes" ; then
	    AC_LINK_IFELSE([AC_LANG_PROGRAM(
	    [[void testfunc(void)
	      {
		asm volatile (".machine \"z13+vx\"\n\t"
			      "vx %%v0, %%v1, %%v31\n\t"
			      "verllf %%v11, %%v11, (16)(0)\n\t"
			      :
			      :
			      : "memory");
	      }
	      ]], [ testfunc(); ])],
	    [gcry_cv_gcc_inline_asm_s390x_vx=yes])
	  fi
	fi])
if test "$gcry_cv_gcc_inline_asm_s390x_vx" = "yes" ; then
   AC_DEFINE(HAVE_GCC_INLINE_ASM_S390X_VX,1,
     [Defined if inline assembler supports zSeries vector instructions])
fi


#
# Check whether GCC inline assembler supports RISC-V instructions
#
AC_CACHE_CHECK([whether GCC inline assembler supports RISC-V instructions],
      [gcry_cv_gcc_inline_asm_riscv],
      [if test "$mpi_cpu_arch" != "riscv64" ||
	  test "$try_asm_modules" != "yes" ; then
	  gcry_cv_gcc_inline_asm_riscv="n/a"
	else
	  gcry_cv_gcc_inline_asm_riscv=no
	  AC_LINK_IFELSE([AC_LANG_PROGRAM(
	  [[unsigned int testfunc(unsigned int x)
	    {
	      unsigned int y;
	      asm volatile ("add %0, %1, %2" :
			    "=r" (y) : "r" (1), "r" (x) : "a5");
	      asm volatile (".option push;\n\t"
			    ".option arch, +zba;\n\t"
			    "sh3add %0, %1, %1;\n\t"
			    ".option pop;\n\t"
			    : "=r" (y)
			    : "r" (y));
	      asm volatile (".option push;\n\t"
			    ".option arch, +zbb;\n\t"
			    "cpop %0, %1;\n\t"
			    ".option pop;\n\t"
			    : "=r" (y)
			    : "r" (y));
	      asm volatile (".option push;\n\t"
			    ".option arch, +zbs;\n\t"
			    "bexti %0, %1, 1;\n\t"
			    ".option pop;\n\t"
			    : "=r" (y)
			    : "r" (y));
	      asm volatile (".option push;\n\t"
			    ".option arch, +zbc;\n\t"
			    "clmulr %0, %1, %2;\n\t"
			    ".option pop;\n\t"
			    : "=r" (y)
			    : "r" (y), "r" (y));
	      return y;
	    }
	    ]] , [ testfunc(0); ])],
	  [gcry_cv_gcc_inline_asm_riscv=yes])
	fi])
if test "$gcry_cv_gcc_inline_asm_riscv" = "yes" ; then
   AC_DEFINE(HAVE_GCC_INLINE_ASM_RISCV,1,
     [Defined if inline assembler supports RISC-V instructions])
fi


#
# Check whether GCC inline assembler supports RISC-V vector instructions
#
AC_CACHE_CHECK([whether GCC inline assembler supports RISC-V vector instructions],
      [gcry_cv_gcc_inline_asm_riscv_v],
      [if test "$mpi_cpu_arch" != "riscv64" ||
	  test "$try_asm_modules" != "yes" ; then
	  gcry_cv_gcc_inline_asm_riscv_v="n/a"
	else
	  gcry_cv_gcc_inline_asm_riscv_v=no
	  if test "$gcry_cv_gcc_inline_asm_riscv" = "yes" ; then
	    AC_LINK_IFELSE([AC_LANG_PROGRAM(
	    [[unsigned int testfunc(void)
	      {
		unsigned int vlmax;
		asm volatile (".option push;\n\t"
			      ".option arch, +v;\n\t"
			      "vsetvli %0, %1, e8, m1, ta, ma;\n\t"
			      "vxor.vv v1, v1, v1;\n\t"
			      ".option pop;\n\t"
			      : "=r" (vlmax)
			      : "r" (~0)
			      : "vl", "vtype", "v1");
		return vlmax;
	      }
	      ]], [ testfunc(); ])],
	    [gcry_cv_gcc_inline_asm_riscv_v=yes])
	  fi
	fi])
if test "$gcry_cv_gcc_inline_asm_riscv_v" = "yes" ; then
   AC_DEFINE(HAVE_GCC_INLINE_ASM_RISCV_V,1,
     [Defined if inline assembler supports RISC-V vector instructions])
fi


#
# Check whether compiler supports RISC-V vector intrinsics
#
AC_CACHE_CHECK([whether compiler supports RISC-V vector intrinsics],
      [gcry_cv_cc_riscv_vector_intrinsics],
      [if test "$mpi_cpu_arch" != "riscv64" ||
	  test "$try_asm_modules" != "yes" ; then
	gcry_cv_cc_riscv_vector_intrinsics="n/a"
      else
	gcry_cv_cc_riscv_vector_intrinsics=no
	AC_COMPILE_IFELSE([AC_LANG_SOURCE(
	[[#if !(defined(__riscv_v_intrinsic) && __riscv_v_intrinsic >= 12000)
	  #error __riscv_v_intrinsic not defined or too old version
	  #endif
	  #include <riscv_vector.h>
	  typedef vuint8m1_t __m128i;
	  #define cast_m128i_to_u64(a) (__riscv_vreinterpret_v_u8m1_u64m1(a))
	  #define cast_u64_to_m128i(a) (__riscv_vreinterpret_v_u64m1_u8m1(a))
	  #define paddq128(a, o) (o = cast_u64_to_m128i( \
					__riscv_vadd_vv_u64m1( \
					  cast_m128i_to_u64(o), \
					  cast_m128i_to_u64(a), 2)))
	  #define pshufb128(m8, o) (o = __riscv_vrgather_vv_u8m1((o), (m8), 16))
	  #define memory_barrier_with_vec(a) __asm__("" : "+vr"(a) :: "memory")
	  #define clear_vec_reg_v0() \
	    __asm__ volatile("vsetivli zero, 16, e8, m1, ta, ma;\n" \
			     "vmv.v.x v0, zero;\n" \
			     ::: "memory", "vtype", "vl", "v0")
	  static inline __attribute__((always_inline)) __m128i
	  fn2(__m128i a)
	  {
	    paddq128(a, a);
	    return a;
	  }
	  __m128i fn(__m128i in)
	  {
	    __m128i x;
	    memory_barrier_with_vec(in);
	    x = fn2(in);
	    memory_barrier_with_vec(x);
	    pshufb128(in, x);
	    memory_barrier_with_vec(in);
	    clear_vec_reg_v0();
	    return in;
	  }
	  ]])],
	[gcry_cv_cc_riscv_vector_intrinsics=yes])
      fi])
if test "$gcry_cv_cc_riscv_vector_intrinsics" = "yes" ; then
    AC_DEFINE(HAVE_COMPATIBLE_CC_RISCV_VECTOR_INTRINSICS,1,
	    [Defined if underlying compiler supports RISC-V vector intrinsics])
fi

_gcc_cflags_save=$CFLAGS
CFLAGS="$CFLAGS -O2 -march=rv64imafdcv -mstrict-align"

if test "$gcry_cv_cc_riscv_vector_intrinsics" = "no" &&
   test "$mpi_cpu_arch" = "riscv64" &&
   test "$try_asm_modules" = "yes" ; then
  AC_CACHE_CHECK([whether compiler supports RISC-V vector intrinsics with extra GCC flags],
    [gcry_cv_cc_riscv_vector_intrinsics_cflags],
    [gcry_cv_cc_riscv_vector_intrinsics_cflags=no
    AC_COMPILE_IFELSE([AC_LANG_SOURCE(
      [[#if !(defined(__riscv_v_intrinsic) && __riscv_v_intrinsic >= 12000)
	#error __riscv_v_intrinsic not defined or too old version
	#endif
	#include <riscv_vector.h>
	typedef vuint8m1_t __m128i;
	#define cast_m128i_to_u64(a) (__riscv_vreinterpret_v_u8m1_u64m1(a))
	#define cast_u64_to_m128i(a) (__riscv_vreinterpret_v_u64m1_u8m1(a))
	#define paddq128(a, o) (o = cast_u64_to_m128i( \
					__riscv_vadd_vv_u64m1( \
					  cast_m128i_to_u64(o), \
					  cast_m128i_to_u64(a), 2)))
	#define pshufb128(m8, o) (o = __riscv_vrgather_vv_u8m1((o), (m8), 16))
	#define memory_barrier_with_vec(a) __asm__("" : "+vr"(a) :: "memory")
	#define clear_vec_reg_v0() \
	  __asm__ volatile("vsetivli zero, 16, e8, m1, ta, ma;\n" \
			    "vmv.v.x v0, zero;\n" \
			    ::: "memory", "vl", "v0")
	static inline __attribute__((always_inline)) __m128i
	fn2(__m128i a)
	{
	  paddq128(a, a);
	  return a;
	}
	__m128i fn(__m128i in)
	{
	  __m128i x;
	  memory_barrier_with_vec(in);
	  x = fn2(in);
	  memory_barrier_with_vec(x);
	  pshufb128(in, x);
	  memory_barrier_with_vec(in);
	  clear_vec_reg_v0();
	  return in;
	}
	]])],
      [gcry_cv_cc_riscv_vector_intrinsics_cflags=yes])])
  if test "$gcry_cv_cc_riscv_vector_intrinsics_cflags" = "yes" ; then
    AC_DEFINE(HAVE_COMPATIBLE_CC_RISCV_VECTOR_INTRINSICS,1,
	      [Defined if underlying compiler supports RISC-V vector intrinsics])
    AC_DEFINE(HAVE_COMPATIBLE_CC_RISCV_VECTOR_INTRINSICS_WITH_CFLAGS,1,
	      [Defined if underlying compiler supports RISC-V vector intrinsics with extra GCC flags])
  fi
fi

AM_CONDITIONAL(ENABLE_RISCV_VECTOR_INTRINSICS_EXTRA_CFLAGS,
	       test "$gcry_cv_cc_riscv_vector_intrinsics_cflags" = "yes")

# Restore flags.
CFLAGS=$_gcc_cflags_save;


#######################################
#### Checks for library functions. ####
#######################################

AC_FUNC_VPRINTF
# We have replacements for these in src/missing-string.c
AC_CHECK_FUNCS(stpcpy strcasecmp)
# We have replacements for these in src/g10lib.h
AC_CHECK_FUNCS(strtoul memmove stricmp atexit raise)
# Other checks
AC_CHECK_FUNCS(strerror rand mmap getpagesize sysconf waitpid wait4)
AC_CHECK_FUNCS(gettimeofday getrusage gethrtime clock_gettime syslog)
AC_CHECK_FUNCS(syscall fcntl ftruncate flockfile getauxval elf_aux_info)
AC_CHECK_FUNCS(explicit_bzero explicit_memset getentropy sysctlbyname)

GNUPG_CHECK_MLOCK

#
# Check whether it is necessary to link against libdl.
#
DL_LIBS=""
if test "$use_hmac_binary_check" != no ; then
  _gcry_save_libs="$LIBS"
  LIBS=""
  AC_SEARCH_LIBS(dlopen, c dl,,,)
  DL_LIBS=$LIBS
  LIBS="$_gcry_save_libs"
fi
AC_SUBST(DL_LIBS)


#
# Check whether we can use Linux capabilities as requested.
#
if test "$use_capabilities" = "yes" ; then
use_capabilities=no
AC_CHECK_HEADERS(sys/capability.h)
if test "$ac_cv_header_sys_capability_h" = "yes" ; then
  AC_CHECK_LIB(cap, cap_init, ac_need_libcap=1)
  if test "$ac_cv_lib_cap_cap_init" = "yes"; then
     AC_DEFINE(USE_CAPABILITIES,1,
               [define if capabilities should be used])
     LIBS="$LIBS -lcap"
     use_capabilities=yes
  fi
fi
if test "$use_capabilities" = "no" ; then
    AC_MSG_WARN([[
***
*** The use of capabilities on this system is not possible.
*** You need a recent Linux kernel and some patches:
***   fcaps-2.2.9-990610.patch      (kernel patch for 2.2.9)
***   fcap-module-990613.tar.gz     (kernel module)
***   libcap-1.92.tar.gz            (user mode library and utilities)
*** And you have to configure the kernel with CONFIG_VFS_CAP_PLUGIN
*** set (filesystems menu). Be warned: This code is *really* ALPHA.
***]])
fi
fi

# Check whether a random device is available.
if test "$try_dev_random" = yes ; then
    AC_CACHE_CHECK(for random device, ac_cv_have_dev_random,
    [if test -r "$NAME_OF_DEV_RANDOM" && test -r "$NAME_OF_DEV_URANDOM" ; then
      ac_cv_have_dev_random=yes; else ac_cv_have_dev_random=no; fi])
    if test "$ac_cv_have_dev_random" = yes; then
        AC_DEFINE(HAVE_DEV_RANDOM,1,
                 [defined if the system supports a random device] )
    fi
else
    AC_MSG_CHECKING(for random device)
    ac_cv_have_dev_random=no
    AC_MSG_RESULT(has been disabled)
fi

# Figure out the random modules for this configuration.
if test "$random" = "default"; then

    # Select default value.
    if test "$ac_cv_func_getentropy" = yes; then
        random_modules="getentropy"
    elif test "$ac_cv_have_dev_random" = yes; then
        # Try Linuxish random device.
        random_modules="linux"
    else
        case "${host}" in
        *-*-mingw32*|*-*-cygwin*)
          # Windows random device.
          random_modules="w32"
          ;;
        *)
          # Build everything, allow selecting at runtime.
          random_modules="$auto_random_modules"
          ;;
        esac
    fi
else
    if test "$random" = "auto"; then
        # Build everything, allow selecting at runtime.
        random_modules="$auto_random_modules"
    else
        random_modules="$random"
    fi
fi


#
# Other defines
#
if test mym4_isgit = "yes"; then
    AC_DEFINE(IS_DEVELOPMENT_VERSION,1,
              [Defined if this is not a regular release])
fi


AM_CONDITIONAL(CROSS_COMPILING, test x$cross_compiling = xyes)


# This is handy for debugging so the compiler doesn't rearrange
# things and eliminate variables.
AC_ARG_ENABLE(optimization,
       AS_HELP_STRING([--disable-optimization],
                      [disable compiler optimization]),
                      [if test $enableval = no ; then
                         CFLAGS=`echo $CFLAGS | sed 's/-O[[0-9]]//'`
                       fi])

AC_MSG_NOTICE([checking for cc features])
# CFLAGS mangling when using gcc.
if test "$GCC" = yes; then
    AC_MSG_CHECKING([if gcc supports -fno-delete-null-pointer-checks])
    _gcc_cflags_save=$CFLAGS
    CFLAGS="-fno-delete-null-pointer-checks"
    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([],[])],_gcc_wopt=yes,_gcc_wopt=no)
    AC_MSG_RESULT($_gcc_wopt)
    CFLAGS=$_gcc_cflags_save;
    if test x"$_gcc_wopt" = xyes ; then
       CFLAGS="$CFLAGS -fno-delete-null-pointer-checks"
    fi

    CFLAGS="$CFLAGS -Wall"
    if test "$USE_MAINTAINER_MODE" = "yes"; then
        CFLAGS="$CFLAGS -Wcast-align -Wshadow -Wstrict-prototypes"
        CFLAGS="$CFLAGS -Wformat -Wno-format-y2k -Wformat-security"

        # If -Wno-missing-field-initializers is supported we can enable a
        # a bunch of really useful warnings.
        AC_MSG_CHECKING([if gcc supports -Wno-missing-field-initializers])
        _gcc_cflags_save=$CFLAGS
        CFLAGS="-Wno-missing-field-initializers"
        AC_COMPILE_IFELSE([AC_LANG_PROGRAM([],[])],_gcc_wopt=yes,_gcc_wopt=no)
        AC_MSG_RESULT($_gcc_wopt)
        CFLAGS=$_gcc_cflags_save;
        if test x"$_gcc_wopt" = xyes ; then
          CFLAGS="$CFLAGS -W -Wextra -Wbad-function-cast"
          CFLAGS="$CFLAGS -Wwrite-strings"
          CFLAGS="$CFLAGS -Wdeclaration-after-statement"
          CFLAGS="$CFLAGS -Wno-missing-field-initializers"
          CFLAGS="$CFLAGS -Wno-sign-compare"
        fi

        AC_MSG_CHECKING([if gcc supports -Wpointer-arith])
        _gcc_cflags_save=$CFLAGS
        CFLAGS="-Wpointer-arith"
        AC_COMPILE_IFELSE([AC_LANG_PROGRAM([],[])],_gcc_wopt=yes,_gcc_wopt=no)
        AC_MSG_RESULT($_gcc_wopt)
        CFLAGS=$_gcc_cflags_save;
        if test x"$_gcc_wopt" = xyes ; then
          CFLAGS="$CFLAGS -Wpointer-arith"
        fi
    fi
fi

# Check whether as(1) supports a noeexecstack feature.  This test
# includes an override option.
CL_AS_NOEXECSTACK


AC_SUBST(LIBGCRYPT_CONFIG_API_VERSION)
AC_SUBST(LIBGCRYPT_CONFIG_LIBS)
AC_SUBST(LIBGCRYPT_CONFIG_CFLAGS)
AC_SUBST(LIBGCRYPT_CONFIG_HOST)
AC_SUBST(LIBGCRYPT_THREAD_MODULES)

AC_CONFIG_COMMANDS([gcrypt-conf],[[
chmod +x src/libgcrypt-config
]],[[
prefix=$prefix
exec_prefix=$exec_prefix
libdir=$libdir
datadir=$datadir
DATADIRNAME=$DATADIRNAME
]])

#####################
#### Conclusion. ####
#####################

# Check that requested feature can actually be used and define
# ENABLE_foo_SUPPORT macros.

if test x"$aesnisupport" = xyes ; then
  if test "$gcry_cv_gcc_inline_asm_ssse3" != "yes" ; then
    aesnisupport="no (unsupported by compiler)"
  fi
fi
if test x"$shaextsupport" = xyes ; then
  if test "$gcry_cv_gcc_inline_asm_shaext" != "yes" ; then
    shaextsupport="no (unsupported by compiler)"
  fi
fi
if test x"$pclmulsupport" = xyes ; then
  if test "$gcry_cv_gcc_inline_asm_pclmul" != "yes" ; then
    pclmulsupport="no (unsupported by compiler)"
  fi
fi
if test x"$sse41support" = xyes ; then
  if test "$gcry_cv_gcc_inline_asm_sse41" != "yes" ; then
    sse41support="no (unsupported by compiler)"
  fi
fi
if test x"$avxsupport" = xyes ; then
  if test "$gcry_cv_gcc_inline_asm_avx" != "yes" ; then
    avxsupport="no (unsupported by compiler)"
  fi
fi
if test x"$avx2support" = xyes ; then
  if test "$gcry_cv_gcc_inline_asm_avx2" != "yes" ; then
    avx2support="no (unsupported by compiler)"
  fi
fi
if test x"$avx512support" = xyes ; then
  if test "$gcry_cv_gcc_inline_asm_avx512" != "yes" ; then
    avx512support="no (unsupported by compiler)"
  fi
fi
if test x"$gfnisupport" = xyes ; then
  if test "$gcry_cv_gcc_inline_asm_gfni" != "yes" ; then
    gfnisupport="no (unsupported by compiler)"
  fi
fi
if test x"$neonsupport" = xyes ; then
  if test "$gcry_cv_gcc_inline_asm_neon" != "yes" ; then
    if test "$gcry_cv_gcc_inline_asm_aarch64_neon" != "yes" ; then
      neonsupport="no (unsupported by compiler)"
    fi
  fi
fi
if test x"$armcryptosupport" = xyes ; then
  if test "$gcry_cv_gcc_inline_asm_aarch32_crypto" != "yes" ; then
    if test "$gcry_cv_gcc_inline_asm_aarch64_crypto" != "yes" ; then
      armcryptosupport="no (unsupported by compiler)"
    fi
  fi
fi
if test x"$svesupport" = xyes ; then
  if test "$gcry_cv_gcc_inline_asm_sve" != "yes" ; then
    if test "$gcry_cv_gcc_inline_asm_aarch64_sve" != "yes" ; then
      svesupport="no (unsupported by compiler)"
    fi
  fi
fi
if test x"$sve2support" = xyes ; then
  if test "$gcry_cv_gcc_inline_asm_sve2" != "yes" ; then
    if test "$gcry_cv_gcc_inline_asm_aarch64_sve2" != "yes" ; then
      sve2support="no (unsupported by compiler)"
    fi
  fi
fi

if test x"$aesnisupport" = xyes ; then
  AC_DEFINE(ENABLE_AESNI_SUPPORT, 1,
            [Enable support for Intel AES-NI instructions.])
fi
if test x"$shaextsupport" = xyes ; then
  AC_DEFINE(ENABLE_SHAEXT_SUPPORT, 1,
            [Enable support for Intel SHAEXT instructions.])
fi
if test x"$pclmulsupport" = xyes ; then
  AC_DEFINE(ENABLE_PCLMUL_SUPPORT, 1,
            [Enable support for Intel PCLMUL instructions.])
fi
if test x"$sse41support" = xyes ; then
  AC_DEFINE(ENABLE_SSE41_SUPPORT, 1,
            [Enable support for Intel SSE4.1 instructions.])
fi
if test x"$avxsupport" = xyes ; then
  AC_DEFINE(ENABLE_AVX_SUPPORT,1,
            [Enable support for Intel AVX instructions.])
fi
if test x"$avx2support" = xyes ; then
  AC_DEFINE(ENABLE_AVX2_SUPPORT,1,
            [Enable support for Intel AVX2 instructions.])
fi
if test x"$avx512support" = xyes ; then
  AC_DEFINE(ENABLE_AVX512_SUPPORT,1,
            [Enable support for Intel AVX512 instructions.])
fi
if test x"$gfnisupport" = xyes ; then
  AC_DEFINE(ENABLE_GFNI_SUPPORT,1,
            [Enable support for Intel GFNI instructions.])
fi
if test x"$neonsupport" = xyes ; then
  AC_DEFINE(ENABLE_NEON_SUPPORT,1,
            [Enable support for ARM NEON instructions.])
fi
if test x"$armcryptosupport" = xyes ; then
  AC_DEFINE(ENABLE_ARM_CRYPTO_SUPPORT,1,
            [Enable support for ARMv8 Crypto Extension instructions.])
fi
if test x"$svesupport" = xyes ; then
  AC_DEFINE(ENABLE_SVE_SUPPORT,1,
            [Enable support for ARMv8 SVE instructions.])
fi
if test x"$sve2support" = xyes ; then
  AC_DEFINE(ENABLE_SVE2_SUPPORT,1,
            [Enable support for ARMv9 SVE2 instructions.])
fi
if test x"$ppccryptosupport" = xyes ; then
  AC_DEFINE(ENABLE_PPC_CRYPTO_SUPPORT,1,
            [Enable support for POWER 8 (PowerISA 2.07) crypto extension.])
fi
if test x"$jentsupport" = xyes ; then
  AC_DEFINE(ENABLE_JENT_SUPPORT, 1,
            [Enable support for the jitter entropy collector.])
fi
if test x"$padlocksupport" = xyes ; then
  AC_DEFINE(ENABLE_PADLOCK_SUPPORT, 1,
            [Enable support for the PadLock engine.])
fi
if test x"$drngsupport" = xyes ; then
  AC_DEFINE(ENABLE_DRNG_SUPPORT, 1,
            [Enable support for Intel DRNG (RDRAND instruction).])
fi


if test x"$force_soft_hwfeatures" = xyes ; then
  AC_DEFINE(ENABLE_FORCE_SOFT_HWFEATURES, 1,
            [Enable forcing 'soft' HW feature bits on (for testing).])
fi

# Define conditional sources and config.h symbols depending on the
# selected ciphers, pubkey-ciphers, digests, kdfs, and random modules.

LIST_MEMBER(arcfour, $enabled_ciphers)
if test "$found" = "1"; then
   GCRYPT_CIPHERS="$GCRYPT_CIPHERS arcfour.lo"
   AC_DEFINE(USE_ARCFOUR, 1, [Defined if this module should be included])

   case "${host}" in
      x86_64-*-*)
         # Build with the assembly implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS arcfour-amd64.lo"
      ;;
   esac
fi

LIST_MEMBER(blowfish, $enabled_ciphers)
if test "$found" = "1" ; then
   GCRYPT_CIPHERS="$GCRYPT_CIPHERS blowfish.lo"
   AC_DEFINE(USE_BLOWFISH, 1, [Defined if this module should be included])

   case "${host}" in
      x86_64-*-*)
         # Build with the assembly implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS blowfish-amd64.lo"
      ;;
      arm*-*-*)
         # Build with the assembly implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS blowfish-arm.lo"
      ;;
   esac
fi

LIST_MEMBER(cast5, $enabled_ciphers)
if test "$found" = "1" ; then
   GCRYPT_CIPHERS="$GCRYPT_CIPHERS cast5.lo"
   AC_DEFINE(USE_CAST5, 1, [Defined if this module should be included])

   case "${host}" in
      x86_64-*-*)
         # Build with the assembly implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS cast5-amd64.lo"
      ;;
      arm*-*-*)
         # Build with the assembly implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS cast5-arm.lo"
      ;;
   esac
fi

LIST_MEMBER(des, $enabled_ciphers)
if test "$found" = "1" ; then
   GCRYPT_CIPHERS="$GCRYPT_CIPHERS des.lo"
   AC_DEFINE(USE_DES, 1, [Defined if this module should be included])

   case "${host}" in
      x86_64-*-*)
         # Build with the assembly implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS des-amd64.lo"
      ;;
   esac
fi

LIST_MEMBER(aes, $enabled_ciphers)
if test "$found" = "1" ; then
   GCRYPT_CIPHERS="$GCRYPT_CIPHERS rijndael.lo"
   AC_DEFINE(USE_AES, 1, [Defined if this module should be included])

   case "${host}" in
      i?86-*-*)
         # Build with the VAES/AVX2 implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS rijndael-vaes-i386.lo"
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS rijndael-vaes-avx2-i386.lo"
      ;;
      x86_64-*-*)
         # Build with the assembly implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS rijndael-amd64.lo"

         # Build with the SSSE3 implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS rijndael-ssse3-amd64.lo"
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS rijndael-ssse3-amd64-asm.lo"

         # Build with the VAES/AVX2 implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS rijndael-vaes.lo"
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS rijndael-vaes-avx2-amd64.lo"
      ;;
      arm*-*-*)
         # Build with the assembly implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS rijndael-arm.lo"

         # Build with the ARMv8/AArch32 CE implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS rijndael-armv8-ce.lo"
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS rijndael-armv8-aarch32-ce.lo"
      ;;
      aarch64-*-*)
         # Build with the assembly implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS rijndael-aarch64.lo"

         # Build with the vector permute SIMD128 implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS rijndael-vp-aarch64.lo"

         # Build with the ARMv8/AArch64 CE implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS rijndael-armv8-ce.lo"
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS rijndael-armv8-aarch64-ce.lo"
      ;;
      powerpc64le-*-*)
         # Build with the crypto extension implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS rijndael-ppc.lo"
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS rijndael-ppc9le.lo"

         if test "$gcry_cv_gcc_inline_asm_ppc_altivec" = "yes" &&
            test "$gcry_cv_gcc_inline_asm_ppc_arch_3_00" = "yes" ; then
            # Build with AES-GCM bulk implementation for P10
            GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS rijndael-gcm-p10le.lo"
            GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS rijndael-p10le.lo"
         fi
      ;;
      powerpc64-*-*)
         # Big-Endian.
         # Build with the crypto extension implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS rijndael-ppc.lo"
      ;;
      powerpc-*-*)
         # Big-Endian.
         # Build with the crypto extension implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS rijndael-ppc.lo"
      ;;
      riscv64-*-*)
         # Build with the vector permute SIMD128 implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS rijndael-vp-riscv.lo"
      ;;
      s390x-*-*)
         # Big-Endian.
         # Build with the crypto extension implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS rijndael-s390x.lo"
      ;;
   esac

   case "$mpi_cpu_arch" in
     x86)
         # Build with the AES-NI implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS rijndael-aesni.lo"

         # Build with the Padlock implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS rijndael-padlock.lo"
      ;;
   esac
fi

LIST_MEMBER(twofish, $enabled_ciphers)
if test "$found" = "1" ; then
   GCRYPT_CIPHERS="$GCRYPT_CIPHERS twofish.lo"
   AC_DEFINE(USE_TWOFISH, 1, [Defined if this module should be included])

   case "${host}" in
      x86_64-*-*)
         # Build with the assembly implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS twofish-amd64.lo"

         if test x"$avx2support" = xyes ; then
            # Build with the AVX2 implementation
            GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS twofish-avx2-amd64.lo"
         fi
      ;;
      arm*-*-*)
         # Build with the assembly implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS twofish-arm.lo"
      ;;
      aarch64-*-*)
         # Build with the assembly implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS twofish-aarch64.lo"
      ;;
   esac
fi

LIST_MEMBER(serpent, $enabled_ciphers)
if test "$found" = "1" ; then
   GCRYPT_CIPHERS="$GCRYPT_CIPHERS serpent.lo"
   AC_DEFINE(USE_SERPENT, 1, [Defined if this module should be included])

   case "${host}" in
      x86_64-*-*)
         # Build with the SSE2 implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS serpent-sse2-amd64.lo"

         if test x"$avx2support" = xyes ; then
            # Build with the AVX2 implementation
            GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS serpent-avx2-amd64.lo"
         fi
      ;;
      arm*-*-*)
         if test x"$neonsupport" = xyes ; then
           # Build with the NEON implementation
           GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS serpent-armv7-neon.lo"
         fi
      ;;
   esac

   if test x"$avx512support" = xyes ; then
      # Build with the AVX512 implementation
      GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS serpent-avx512-x86.lo"
   fi
fi

LIST_MEMBER(rfc2268, $enabled_ciphers)
if test "$found" = "1" ; then
   GCRYPT_CIPHERS="$GCRYPT_CIPHERS rfc2268.lo"
   AC_DEFINE(USE_RFC2268, 1, [Defined if this module should be included])
fi

LIST_MEMBER(seed, $enabled_ciphers)
if test "$found" = "1" ; then
   GCRYPT_CIPHERS="$GCRYPT_CIPHERS seed.lo"
   AC_DEFINE(USE_SEED, 1, [Defined if this module should be included])
fi

LIST_MEMBER(camellia, $enabled_ciphers)
if test "$found" = "1" ; then
   GCRYPT_CIPHERS="$GCRYPT_CIPHERS camellia.lo camellia-glue.lo"
   AC_DEFINE(USE_CAMELLIA, 1, [Defined if this module should be included])

   case "${host}" in
      arm*-*-*)
         # Build with the assembly implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS camellia-arm.lo"
      ;;
      aarch64-*-*)
         # Build with the assembly implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS camellia-aarch64.lo"
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS camellia-aarch64-ce.lo"
      ;;
      powerpc64le-*-*)
         # Build with the POWER vector implementations
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS camellia-ppc8le.lo"
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS camellia-ppc9le.lo"
      ;;
   esac

   case "${host}" in
      x86_64-*-*)
         if test x"$avxsupport" = xyes ; then
            if test x"$aesnisupport" = xyes ; then
              # Build with the AES-NI/AVX implementation
              GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS camellia-aesni-avx-amd64.lo"
            fi
         fi

         if test x"$avx2support" = xyes ; then
            if test x"$aesnisupport" = xyes ; then
              # Build with the AES-NI/AVX2 implementation
              GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS camellia-aesni-avx2-amd64.lo"

              # Build with the VAES/AVX2 implementation
              GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS camellia-vaes-avx2-amd64.lo"

              # Build with the GFNI/AVX2 implementation
              GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS camellia-gfni-avx2-amd64.lo"

              # Build with the GFNI/AVX512 implementation
              GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS camellia-gfni-avx512-amd64.lo"
            fi
         fi
      ;;
   esac
fi

LIST_MEMBER(idea, $enabled_ciphers)
if test "$found" = "1" ; then
   GCRYPT_CIPHERS="$GCRYPT_CIPHERS idea.lo"
   AC_DEFINE(USE_IDEA, 1, [Defined if this module should be included])
fi

LIST_MEMBER(salsa20, $enabled_ciphers)
if test "$found" = "1" ; then
   GCRYPT_CIPHERS="$GCRYPT_CIPHERS salsa20.lo"
   AC_DEFINE(USE_SALSA20, 1, [Defined if this module should be included])

   case "${host}" in
      x86_64-*-*)
         # Build with the assembly implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS salsa20-amd64.lo"
      ;;
      arm*-*-*)
         if test x"$neonsupport" = xyes ; then
            # Build with the NEON implementation
            GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS salsa20-armv7-neon.lo"
         fi
      ;;
   esac
fi

LIST_MEMBER(gost28147, $enabled_ciphers)
if test "$found" = "1" ; then
   GCRYPT_CIPHERS="$GCRYPT_CIPHERS gost28147.lo"
   AC_DEFINE(USE_GOST28147, 1, [Defined if this module should be included])
fi

LIST_MEMBER(chacha20, $enabled_ciphers)
if test "$found" = "1" ; then
   GCRYPT_CIPHERS="$GCRYPT_CIPHERS chacha20.lo"
   AC_DEFINE(USE_CHACHA20, 1, [Defined if this module should be included])

   case "${host}" in
      x86_64-*-*)
         # Build with the assembly implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS chacha20-amd64-ssse3.lo"
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS chacha20-amd64-avx2.lo"
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS chacha20-amd64-avx512.lo"
      ;;
      arm*-*-*)
         if test x"$neonsupport" = xyes ; then
            # Build with the NEON implementation
            GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS chacha20-armv7-neon.lo"
         fi
      ;;
      aarch64-*-*)
         # Build with the assembly implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS chacha20-aarch64.lo"
      ;;
      powerpc64le-*-*)
         # Build with the ppc8 vector implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS chacha20-ppc.lo"
         # Build with the assembly implementation
         if test "$gcry_cv_gcc_inline_asm_ppc_altivec" = "yes" &&
            test "$gcry_cv_gcc_inline_asm_ppc_arch_3_00" = "yes" ; then
            GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS chacha20-p10le-8x.lo"
         fi
      ;;
      powerpc64-*-*)
         # Build with the ppc8 vector implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS chacha20-ppc.lo"
      ;;
      powerpc-*-*)
         # Build with the ppc8 vector implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS chacha20-ppc.lo"
      ;;
      s390x-*-*)
         # Build with the s390x/zSeries vector implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS chacha20-s390x.lo"
      ;;
      riscv64-*-*)
         # Build with the RISC-V vector implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS chacha20-riscv-v.lo"
      ;;
   esac
fi

LIST_MEMBER(sm4, $enabled_ciphers)
if test "$found" = "1" ; then
   GCRYPT_CIPHERS="$GCRYPT_CIPHERS sm4.lo"
   AC_DEFINE(USE_SM4, 1, [Defined if this module should be included])

   case "${host}" in
      x86_64-*-*)
         # Build with the assembly implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS sm4-aesni-avx-amd64.lo"
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS sm4-aesni-avx2-amd64.lo"
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS sm4-gfni-avx2-amd64.lo"
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS sm4-gfni-avx512-amd64.lo"
      ;;
      aarch64-*-*)
         # Build with the assembly implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS sm4-aarch64.lo"
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS sm4-armv8-aarch64-ce.lo"
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS sm4-armv9-aarch64-sve-ce.lo"
      ;;
      powerpc64le-*-*)
         # Build with the ppc64le vector implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS sm4-ppc.lo"
      ;;
   esac
fi

LIST_MEMBER(aria, $enabled_ciphers)
if test "$found" = "1" ; then
   GCRYPT_CIPHERS="$GCRYPT_CIPHERS aria.lo"
   AC_DEFINE(USE_ARIA, 1, [Defined if this module should be included])

   case "${host}" in
      x86_64-*-*)
         # Build with the assembly implementation
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS aria-aesni-avx-amd64.lo"
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS aria-aesni-avx2-amd64.lo"
         GCRYPT_ASM_CIPHERS="$GCRYPT_ASM_CIPHERS aria-gfni-avx512-amd64.lo"
      ;;
   esac
fi

LIST_MEMBER(dsa, $enabled_pubkey_ciphers)
AM_CONDITIONAL(USE_DSA, [test "$found" = "1"])
if test "$found" = "1" ; then
   GCRYPT_PUBKEY_CIPHERS="$GCRYPT_PUBKEY_CIPHERS dsa.lo"
   AC_DEFINE(USE_DSA, 1, [Defined if this module should be included])
fi

LIST_MEMBER(rsa, $enabled_pubkey_ciphers)
AM_CONDITIONAL(USE_RSA, [test "$found" = "1"])
if test "$found" = "1" ; then
   GCRYPT_PUBKEY_CIPHERS="$GCRYPT_PUBKEY_CIPHERS rsa.lo"
   AC_DEFINE(USE_RSA, 1, [Defined if this module should be included])
fi

LIST_MEMBER(elgamal, $enabled_pubkey_ciphers)
AM_CONDITIONAL(USE_ELGAMAL, [test "$found" = "1"])
if test "$found" = "1" ; then
   GCRYPT_PUBKEY_CIPHERS="$GCRYPT_PUBKEY_CIPHERS elgamal.lo"
   AC_DEFINE(USE_ELGAMAL, 1, [Defined if this module should be included])
fi

LIST_MEMBER(ecc, $enabled_pubkey_ciphers)
AM_CONDITIONAL(USE_ECC, [test "$found" = "1"])
if test "$found" = "1" ; then
   GCRYPT_PUBKEY_CIPHERS="$GCRYPT_PUBKEY_CIPHERS \
                          ecc.lo ecc-curves.lo ecc-misc.lo \
                          ecc-ecdh.lo ecc-ecdsa.lo ecc-eddsa.lo ecc-gost.lo \
                          ecc-sm2.lo"
   AC_DEFINE(USE_ECC, 1, [Defined if this module should be included])
fi

LIST_MEMBER(kyber, $enabled_pubkey_ciphers)
AM_CONDITIONAL(USE_KYBER, [test "$found" = "1"])
if test "$found" = "1" ; then
   GCRYPT_PUBKEY_CIPHERS="$GCRYPT_PUBKEY_CIPHERS \
                          kyber.c"
   AC_DEFINE(USE_KYBER, 1, [Defined if this module should be included])
fi

LIST_MEMBER(crc, $enabled_digests)
if test "$found" = "1" ; then
   GCRYPT_DIGESTS="$GCRYPT_DIGESTS crc.lo"
   AC_DEFINE(USE_CRC, 1, [Defined if this module should be included])

   case "${host}" in
      i?86-*-* | x86_64-*-*)
         # Build with the assembly implementation
         GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS crc-intel-pclmul.lo"
      ;;
      aarch64-*-*)
         # Build with the assembly implementation
         GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS crc-armv8-ce.lo"
         GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS crc-armv8-aarch64-ce.lo"
      ;;
      powerpc64le-*-*)
         GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS crc-ppc.lo"
      ;;
      powerpc64-*-*)
         GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS crc-ppc.lo"
      ;;
      powerpc-*-*)
         GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS crc-ppc.lo"
      ;;
   esac
fi

LIST_MEMBER(gostr3411-94, $enabled_digests)
if test "$found" = "1" ; then
   # GOST R 34.11-94 internally uses GOST 28147-89
   LIST_MEMBER(gost28147, $enabled_ciphers)
   if test "$found" = "1" ; then
      GCRYPT_DIGESTS="$GCRYPT_DIGESTS gostr3411-94.lo"
      AC_DEFINE(USE_GOST_R_3411_94, 1, [Defined if this module should be included])
   fi
fi

LIST_MEMBER(stribog, $enabled_digests)
if test "$found" = "1" ; then
   GCRYPT_DIGESTS="$GCRYPT_DIGESTS stribog.lo"
   AC_DEFINE(USE_GOST_R_3411_12, 1, [Defined if this module should be included])
fi

LIST_MEMBER(md2, $enabled_digests)
if test "$found" = "1" ; then
   GCRYPT_DIGESTS="$GCRYPT_DIGESTS md2.lo"
   AC_DEFINE(USE_MD2, 1, [Defined if this module should be included])
fi

LIST_MEMBER(md4, $enabled_digests)
if test "$found" = "1" ; then
   GCRYPT_DIGESTS="$GCRYPT_DIGESTS md4.lo"
   AC_DEFINE(USE_MD4, 1, [Defined if this module should be included])
fi

LIST_MEMBER(md5, $enabled_digests)
if test "$found" = "1" ; then
   GCRYPT_DIGESTS="$GCRYPT_DIGESTS md5.lo"
   AC_DEFINE(USE_MD5, 1, [Defined if this module should be included])
fi

LIST_MEMBER(rmd160, $enabled_digests)
if test "$found" = "1" ; then
   GCRYPT_DIGESTS="$GCRYPT_DIGESTS rmd160.lo"
   AC_DEFINE(USE_RMD160, 1, [Defined if this module should be included])
fi

LIST_MEMBER(sha256, $enabled_digests)
if test "$found" = "1" ; then
   GCRYPT_DIGESTS="$GCRYPT_DIGESTS sha256.lo"
   AC_DEFINE(USE_SHA256, 1, [Defined if this module should be included])

   case "${host}" in
      x86_64-*-*)
         # Build with the assembly implementation
         GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS sha256-ssse3-amd64.lo"
         GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS sha256-avx-amd64.lo"
         GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS sha256-avx2-bmi2-amd64.lo"
      ;;
      arm*-*-*)
         # Build with the assembly implementation
         GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS sha256-armv8-aarch32-ce.lo"
      ;;
      aarch64-*-*)
         # Build with the assembly implementation
         GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS sha256-armv8-aarch64-ce.lo"
      ;;
      powerpc64le-*-*)
         # Build with the crypto extension implementation
         GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS sha256-ppc.lo"
      ;;
      powerpc64-*-*)
         # Big-Endian.
         # Build with the crypto extension implementation
         GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS sha256-ppc.lo"
      ;;
      powerpc-*-*)
         # Big-Endian.
         # Build with the crypto extension implementation
         GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS sha256-ppc.lo"
   esac

   case "$mpi_cpu_arch" in
     x86)
       # Build with the SHAEXT implementation
       GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS sha256-intel-shaext.lo"
     ;;
   esac
fi

LIST_MEMBER(sha512, $enabled_digests)
if test "$found" = "1" ; then
   GCRYPT_DIGESTS="$GCRYPT_DIGESTS sha512.lo"
   AC_DEFINE(USE_SHA512, 1, [Defined if this module should be included])

   case "${host}" in
      x86_64-*-*)
         # Build with the assembly implementation
         GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS sha512-ssse3-amd64.lo"
         GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS sha512-avx-amd64.lo"
         GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS sha512-avx2-bmi2-amd64.lo"
         GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS sha512-avx512-amd64.lo"
      ;;
      i?86-*-*)
         # Build with the assembly implementation
         GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS sha512-ssse3-i386.lo"
      ;;
      arm*-*-*)
         # Build with the assembly implementation
         GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS sha512-arm.lo"

         if test x"$neonsupport" = xyes ; then
            # Build with the NEON implementation
            GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS sha512-armv7-neon.lo"
         fi
      ;;
      aarch64-*-*)
         # Build with the assembly implementation
         GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS sha512-armv8-aarch64-ce.lo"
      ;;
      powerpc64le-*-*)
         # Build with the crypto extension implementation
         GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS sha512-ppc.lo"
      ;;
      powerpc64-*-*)
         # Big-Endian.
         # Build with the crypto extension implementation
         GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS sha512-ppc.lo"
      ;;
      powerpc-*-*)
         # Big-Endian.
         # Build with the crypto extension implementation
         GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS sha512-ppc.lo"
   esac
fi

LIST_MEMBER(sha3, $enabled_digests)
if test "$found" = "1" ; then
   GCRYPT_DIGESTS="$GCRYPT_DIGESTS keccak.lo"
   AC_DEFINE(USE_SHA3, 1, [Defined if this module should be included])

   case "${host}" in
      x86_64-*-*)
         # Build with the assembly implementation
         GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS keccak-amd64-avx512.lo"
      ;;
      arm*-*-*)
         if test x"$neonsupport" = xyes ; then
           # Build with the NEON implementation
           GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS keccak-armv7-neon.lo"
         fi
      ;;
   esac
fi

LIST_MEMBER(tiger, $enabled_digests)
if test "$found" = "1" ; then
   GCRYPT_DIGESTS="$GCRYPT_DIGESTS tiger.lo"
   AC_DEFINE(USE_TIGER, 1, [Defined if this module should be included])
fi

LIST_MEMBER(whirlpool, $enabled_digests)
if test "$found" = "1" ; then
   GCRYPT_DIGESTS="$GCRYPT_DIGESTS whirlpool.lo"
   AC_DEFINE(USE_WHIRLPOOL, 1, [Defined if this module should be included])

   case "${host}" in
      x86_64-*-*)
         # Build with the assembly implementation
         GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS whirlpool-sse2-amd64.lo"
      ;;
   esac
fi

LIST_MEMBER(blake2, $enabled_digests)
if test "$found" = "1" ; then
   GCRYPT_DIGESTS="$GCRYPT_DIGESTS blake2.lo"
   AC_DEFINE(USE_BLAKE2, 1, [Defined if this module should be included])

   case "${host}" in
      x86_64-*-*)
         # Build with the assembly implementation
         GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS blake2b-amd64-avx2.lo"
         GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS blake2b-amd64-avx512.lo"
         GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS blake2s-amd64-avx.lo"
         GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS blake2s-amd64-avx512.lo"
      ;;
   esac
fi

LIST_MEMBER(sm3, $enabled_digests)
if test "$found" = "1" ; then
   GCRYPT_DIGESTS="$GCRYPT_DIGESTS sm3.lo"
   AC_DEFINE(USE_SM3, 1, [Defined if this module should be included])

   case "${host}" in
     x86_64-*-*)
        # Build with the assembly implementation
        GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS sm3-avx-bmi2-amd64.lo"
     ;;
     aarch64-*-*)
        # Build with the assembly implementation
        GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS sm3-aarch64.lo"
        GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS sm3-armv8-aarch64-ce.lo"
     ;;
   esac
fi

# SHA-1 needs to be included always for example because it is used by
# random-csprng.c.
GCRYPT_DIGESTS="$GCRYPT_DIGESTS sha1.lo"
AC_DEFINE(USE_SHA1, 1,   [Defined if this module should be included])

case "${host}" in
  x86_64-*-*)
    # Build with the assembly implementation
    GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS sha1-ssse3-amd64.lo"
    GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS sha1-avx-amd64.lo"
    GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS sha1-avx-bmi2-amd64.lo"
    GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS sha1-avx2-bmi2-amd64.lo"
  ;;
  arm*-*-*)
    # Build with the assembly implementation
    GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS sha1-armv7-neon.lo"
    GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS sha1-armv8-aarch32-ce.lo"
  ;;
  aarch64-*-*)
    # Build with the assembly implementation
    GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS sha1-armv8-aarch64-ce.lo"
  ;;
esac

case "$mpi_cpu_arch" in
  x86)
    # Build with the SHAEXT implementation
    GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS sha1-intel-shaext.lo"
  ;;
esac

# Arch specific GCM implementations
case "${host}" in
  i?86-*-* | x86_64-*-*)
    GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS cipher-gcm-intel-pclmul.lo"
  ;;
  arm*-*-*)
    GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS cipher-gcm-armv7-neon.lo"
    GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS cipher-gcm-armv8-aarch32-ce.lo"
  ;;
  aarch64-*-*)
    GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS cipher-gcm-aarch64-simd.lo"
    GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS cipher-gcm-armv8-aarch64-ce.lo"
  ;;
  powerpc64le-*-* | powerpc64-*-* | powerpc-*-*)
    GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS cipher-gcm-ppc.lo"
  ;;
  riscv64-*-*)
    GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS cipher-gcm-riscv-zbb-zbc.lo"
  ;;
esac

# Arch specific MAC implementations
case "${host}" in
  s390x-*-*)
    GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS poly1305-s390x.lo"
  ;;
  x86_64-*-*)
    GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS poly1305-amd64-avx512.lo"
  ;;
  powerpc64le-*-*)
    # Build with the assembly implementation
    if test "$gcry_cv_gcc_inline_asm_ppc_altivec" = "yes" &&
       test "$gcry_cv_gcc_inline_asm_ppc_arch_3_00" = "yes" ; then
       GCRYPT_ASM_DIGESTS="$GCRYPT_ASM_DIGESTS poly1305-p10le.lo"
    fi
  ;;
esac

LIST_MEMBER(scrypt, $enabled_kdfs)
if test "$found" = "1" ; then
   GCRYPT_KDFS="$GCRYPT_KDFS scrypt.lo"
   AC_DEFINE(USE_SCRYPT, 1, [Defined if this module should be included])
fi

LIST_MEMBER(getentropy, $random_modules)
if test "$found" = "1" ; then
   GCRYPT_RANDOM="$GCRYPT_RANDOM rndgetentropy.lo"
   AC_DEFINE(USE_RNDGETENTROPY, 1, [Defined if the getentropy RNG should be used.])
fi

LIST_MEMBER(linux, $random_modules)
if test "$found" = "1" ; then
   GCRYPT_RANDOM="$GCRYPT_RANDOM rndoldlinux.lo"
   AC_DEFINE(USE_RNDOLDLINUX, 1, [Defined if the /dev/random RNG should be used.])
fi

LIST_MEMBER(unix, $random_modules)
if test "$found" = "1" ; then
   GCRYPT_RANDOM="$GCRYPT_RANDOM rndunix.lo"
   AC_DEFINE(USE_RNDUNIX, 1, [Defined if the default Unix RNG should be used.])
fi

LIST_MEMBER(egd, $random_modules)
if test "$found" = "1" ; then
   GCRYPT_RANDOM="$GCRYPT_RANDOM rndegd.lo"
   AC_DEFINE(USE_RNDEGD, 1, [Defined if the EGD based RNG should be used.])
fi

LIST_MEMBER(w32, $random_modules)
if test "$found" = "1" ; then
   GCRYPT_RANDOM="$GCRYPT_RANDOM rndw32.lo"
   AC_DEFINE(USE_RNDW32, 1,
             [Defined if the Windows specific RNG should be used.])
fi

if test "$try_asm_modules" = yes ; then
  # Build with assembly implementations
  GCRYPT_CIPHERS="$GCRYPT_CIPHERS $GCRYPT_ASM_CIPHERS"
  GCRYPT_DIGESTS="$GCRYPT_DIGESTS $GCRYPT_ASM_DIGESTS"
fi

AC_SUBST([GCRYPT_CIPHERS])
AC_SUBST([GCRYPT_PUBKEY_CIPHERS])
AC_SUBST([GCRYPT_DIGESTS])
AC_SUBST([GCRYPT_KDFS])
AC_SUBST([GCRYPT_RANDOM])

AC_SUBST(LIBGCRYPT_CIPHERS, $enabled_ciphers)
AC_SUBST(LIBGCRYPT_PUBKEY_CIPHERS, $enabled_pubkey_ciphers)
AC_SUBST(LIBGCRYPT_DIGESTS, $enabled_digests)

# For printing the configuration we need a colon separated list of
# algorithm names.
tmp=`echo "$enabled_ciphers" | tr ' ' : `
AC_DEFINE_UNQUOTED(LIBGCRYPT_CIPHERS, "$tmp",
                   [List of available cipher algorithms])
tmp=`echo "$enabled_pubkey_ciphers" | tr ' ' : `
AC_DEFINE_UNQUOTED(LIBGCRYPT_PUBKEY_CIPHERS, "$tmp",
                   [List of available public key cipher algorithms])
tmp=`echo "$enabled_digests" | tr ' ' : `
AC_DEFINE_UNQUOTED(LIBGCRYPT_DIGESTS, "$tmp",
                   [List of available digest algorithms])
tmp=`echo "$enabled_kdfs" | tr ' ' : `
AC_DEFINE_UNQUOTED(LIBGCRYPT_KDFS, "$tmp",
                   [List of available KDF algorithms])


#
# Define conditional sources depending on the used hardware platform.
# Note that all possible modules must also be listed in
# src/Makefile.am (EXTRA_libgcrypt_la_SOURCES).
#
GCRYPT_HWF_MODULES=
case "$mpi_cpu_arch" in
     x86)
        AC_DEFINE(HAVE_CPU_ARCH_X86, 1,   [Defined for the x86 platforms])
        GCRYPT_HWF_MODULES="libgcrypt_la-hwf-x86.lo"
        ;;
     alpha)
        AC_DEFINE(HAVE_CPU_ARCH_ALPHA, 1, [Defined for Alpha platforms])
        ;;
     sparc)
        AC_DEFINE(HAVE_CPU_ARCH_SPARC, 1, [Defined for SPARC platforms])
        ;;
     mips)
        AC_DEFINE(HAVE_CPU_ARCH_MIPS, 1,  [Defined for MIPS platforms])
        ;;
     m68k)
        AC_DEFINE(HAVE_CPU_ARCH_M68K, 1,  [Defined for M68k platforms])
        ;;
     ppc)
        AC_DEFINE(HAVE_CPU_ARCH_PPC, 1,   [Defined for PPC platforms])
        GCRYPT_HWF_MODULES="libgcrypt_la-hwf-ppc.lo"
        ;;
     arm)
        AC_DEFINE(HAVE_CPU_ARCH_ARM, 1,   [Defined for ARM platforms])
        GCRYPT_HWF_MODULES="libgcrypt_la-hwf-arm.lo"
        ;;
     aarch64)
        AC_DEFINE(HAVE_CPU_ARCH_ARM, 1,   [Defined for ARM AArch64 platforms])
        GCRYPT_HWF_MODULES="libgcrypt_la-hwf-arm.lo"
        ;;
     s390x)
        AC_DEFINE(HAVE_CPU_ARCH_S390X, 1, [Defined for s390x/zSeries platforms])
        GCRYPT_HWF_MODULES="libgcrypt_la-hwf-s390x.lo"
        ;;
     riscv64)
        AC_DEFINE(HAVE_CPU_ARCH_RISCV, 1, [Defined for RISC-V platforms])
        GCRYPT_HWF_MODULES="libgcrypt_la-hwf-riscv.lo"
        ;;
esac
AC_SUBST([GCRYPT_HWF_MODULES])


#
# Option to disable building of doc file
#
build_doc=yes
AC_ARG_ENABLE([doc], AS_HELP_STRING([--disable-doc],
                                    [do not build the documentation]),
                     build_doc=$enableval, build_doc=yes)
AM_CONDITIONAL([BUILD_DOC], [test "x$build_doc" != xno])


#
# Provide information about the build.
#
BUILD_REVISION="mym4_revision"
AC_SUBST(BUILD_REVISION)
AC_DEFINE_UNQUOTED(BUILD_REVISION, "$BUILD_REVISION",
                   [GIT commit id revision used to build this package])

changequote(,)dnl
BUILD_VERSION=`echo "$PACKAGE_VERSION" | sed 's/\([0-9.]*\).*/\1./'`
changequote([,])dnl
BUILD_VERSION="${BUILD_VERSION}mym4_revision_dec"
BUILD_FILEVERSION=`echo "${BUILD_VERSION}" | tr . ,`
AC_SUBST(BUILD_VERSION)
AC_SUBST(BUILD_FILEVERSION)

AC_ARG_ENABLE([build-timestamp],
  AS_HELP_STRING([--enable-build-timestamp],
                 [set an explicit build timestamp for reproducibility.
                  (default is the current time in ISO-8601 format)]),
     [if test "$enableval" = "yes"; then
        BUILD_TIMESTAMP=`date -u +%Y-%m-%dT%H:%M+0000 2>/dev/null || date`
      else
        BUILD_TIMESTAMP="$enableval"
      fi],
     [BUILD_TIMESTAMP="<none>"])
AC_SUBST(BUILD_TIMESTAMP)
AC_DEFINE_UNQUOTED(BUILD_TIMESTAMP, "$BUILD_TIMESTAMP",
                   [The time this package was configured for a build])


# And create the files.
AC_CONFIG_FILES([
Makefile
m4/Makefile
compat/Makefile
mpi/Makefile
cipher/Makefile
random/Makefile
doc/Makefile
src/Makefile
src/gcrypt.h
src/libgcrypt-config
src/libgcrypt.pc
src/versioninfo.rc
tests/Makefile
])
AC_CONFIG_FILES([tests/hashtest-6g], [chmod +x tests/hashtest-6g])
AC_CONFIG_FILES([tests/hashtest-256g], [chmod +x tests/hashtest-256g])
AC_CONFIG_FILES([tests/basic-disable-all-hwf], [chmod +x tests/basic-disable-all-hwf])
AC_OUTPUT


detection_module="${GCRYPT_HWF_MODULES%.lo}"
test -n "$detection_module" || detection_module="none"

# Give some feedback
GCRY_MSG_SHOW([],[])
GCRY_MSG_SHOW([Libgcrypt],[v${VERSION} has been configured as follows:])
GCRY_MSG_SHOW([],[])
GCRY_MSG_SHOW([Platform:                 ],[$PRINTABLE_OS_NAME ($host)])
GCRY_MSG_SHOW([Hardware detection module:],[$detection_module])
GCRY_MSG_WRAP([Enabled cipher algorithms:],[$enabled_ciphers])
GCRY_MSG_WRAP([Enabled digest algorithms:],[$enabled_digests])
GCRY_MSG_WRAP([Enabled kdf algorithms:   ],[$enabled_kdfs])
GCRY_MSG_WRAP([Enabled pubkey algorithms:],[$enabled_pubkey_ciphers])
GCRY_MSG_SHOW([Random number generator:  ],[$random])
GCRY_MSG_SHOW([Try using jitter entropy: ],[$jentsupport])
GCRY_MSG_SHOW([Using linux capabilities: ],[$use_capabilities])
GCRY_MSG_SHOW([FIPS module version:      ],[$fips_module_version])
GCRY_MSG_SHOW([Try using Padlock crypto: ],[$padlocksupport])
GCRY_MSG_SHOW([Try using AES-NI crypto:  ],[$aesnisupport])
GCRY_MSG_SHOW([Try using Intel SHAEXT:   ],[$shaextsupport])
GCRY_MSG_SHOW([Try using Intel PCLMUL:   ],[$pclmulsupport])
GCRY_MSG_SHOW([Try using Intel SSE4.1:   ],[$sse41support])
GCRY_MSG_SHOW([Try using DRNG (RDRAND):  ],[$drngsupport])
GCRY_MSG_SHOW([Try using Intel AVX:      ],[$avxsupport])
GCRY_MSG_SHOW([Try using Intel AVX2:     ],[$avx2support])
GCRY_MSG_SHOW([Try using Intel AVX512:   ],[$avx512support])
GCRY_MSG_SHOW([Try using Intel GFNI:     ],[$gfnisupport])
GCRY_MSG_SHOW([Try using ARM NEON:       ],[$neonsupport])
GCRY_MSG_SHOW([Try using ARMv8 crypto:   ],[$armcryptosupport])
GCRY_MSG_SHOW([Try using ARMv8 SVE:      ],[$svesupport])
GCRY_MSG_SHOW([Try using ARMv9 SVE2:     ],[$sve2support])
GCRY_MSG_SHOW([Try using PPC crypto:     ],[$ppccryptosupport])
GCRY_MSG_SHOW([],[])

if test "x${gpg_config_script_warn}" != x; then
cat <<G10EOF
        Mismatches between the target platform and the to
        be used libraries have been been detected for:
         ${gpg_config_script_warn}
        Please check above for warning messages.

G10EOF
fi

if test "$gcry_cv_gcc_attribute_aligned" != "yes" ; then
cat <<G10EOF
   Please note that your compiler does not support the GCC style
   aligned attribute. Using this software may evoke bus errors.

G10EOF
fi
